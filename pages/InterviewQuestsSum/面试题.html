<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>小女生首页</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/photo.jpg">
    <meta name="description" content="小女生的前端记录">
    
    <link rel="preload" href="/assets/css/0.styles.723d6123.css" as="style"><link rel="preload" href="/assets/js/app.2d1dd0b0.js" as="script"><link rel="preload" href="/assets/js/2.07c258a3.js" as="script"><link rel="preload" href="/assets/js/4.7c3dfb1b.js" as="script"><link rel="prefetch" href="/assets/js/10.53e90345.js"><link rel="prefetch" href="/assets/js/11.21a5b5ff.js"><link rel="prefetch" href="/assets/js/12.024859e6.js"><link rel="prefetch" href="/assets/js/13.a9dc1bfe.js"><link rel="prefetch" href="/assets/js/14.1ea943f5.js"><link rel="prefetch" href="/assets/js/15.d7d1d2ad.js"><link rel="prefetch" href="/assets/js/16.3dc60ad1.js"><link rel="prefetch" href="/assets/js/17.266395e8.js"><link rel="prefetch" href="/assets/js/18.9ae13edc.js"><link rel="prefetch" href="/assets/js/19.6ddfd93e.js"><link rel="prefetch" href="/assets/js/20.11446c36.js"><link rel="prefetch" href="/assets/js/3.71dfdb29.js"><link rel="prefetch" href="/assets/js/5.abcf9e59.js"><link rel="prefetch" href="/assets/js/6.3a87541a.js"><link rel="prefetch" href="/assets/js/7.b7cc106e.js"><link rel="prefetch" href="/assets/js/8.c0828407.js"><link rel="prefetch" href="/assets/js/9.c75cd91a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.723d6123.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/photo.jpg" alt="小女生首页" class="logo"> <span class="site-name can-hide">小女生首页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/TScript/01-TypeScript基本介绍.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/pages/folder2/test4.html" class="nav-link">
  琐碎
</a></li></ul></div></div><div class="nav-item"><a href="/pages/folder1/test3.html" class="nav-link">
  功能演示
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/TScript/01-TypeScript基本介绍.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/pages/folder2/test4.html" class="nav-link">
  琐碎
</a></li></ul></div></div><div class="nav-item"><a href="/pages/folder1/test3.html" class="nav-link">
  功能演示
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/TScript/01-TypeScript基本介绍.html" class="sidebar-link">01-TypeScript基本介绍</a></li><li><a href="/pages/TScript/02-TypeScript运算符、条件语句、循环、函数、断点调试.html" class="sidebar-link">02-TypeScript运算符、条件语TScript/句、循环、函数、断点调试</a></li><li><a href="/pages/TScript/03-Number、String、Array、Map、Object.html" class="sidebar-link">03-Number、String、Array、Map、ObTScript/ject</a></li><li><a href="/pages/TScript/04-元组、联合类型、接口.html" class="sidebar-link">04-元组、联合类型、接口</a></li><li><a href="/pages/TScript/05-类、对象、命名空间.html" class="sidebar-link">05-类、对象、命名空间</a></li><li><a href="/pages/TScript/06-类型断言、解构、展开.html" class="sidebar-link">06-类型断言、解构、展开</a></li><li><a href="/pages/TScript/07-模块、声明文件.html" class="sidebar-link">07-模块、声明文件</a></li><li><a href="/pages/TScript/08-变量声明.html" class="sidebar-link">08-变量声明</a></li><li><a href="/pages/TScript/案例-下棋游戏（XXOO）.html" class="sidebar-link">案例-下棋游戏（XXOO）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue3</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Vue3/vue3快速上手.html" class="sidebar-link">vue3快速上手</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试题总结</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/InterviewQuestsSum/面试题.html" class="active sidebar-link">面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第一部分-html-css" class="sidebar-link">第一部分：html/css</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第二部分-javascript" class="sidebar-link">第二部分：JavaScript</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第三部分-jquery" class="sidebar-link">第三部分：jQuery</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第四部分-vue" class="sidebar-link">第四部分：vue</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第五部分-react" class="sidebar-link">第五部分：react</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第六部分-es6" class="sidebar-link">第六部分：ES6</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第七部分-小程序" class="sidebar-link">第七部分：小程序</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第七部分-优化" class="sidebar-link">第七部分：优化</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第八部分-计算机基础" class="sidebar-link">第八部分：计算机基础</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第十部分-扩展" class="sidebar-link">第十部分：扩展</a></li><li class="sidebar-sub-header"><a href="/pages/InterviewQuestsSum/面试题.html#第十一部分-项目" class="sidebar-link">第十一部分：项目</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>面试题</p> <h2 id="第一部分-html-css"><a href="#第一部分-html-css" class="header-anchor">#</a> 第一部分：html/css</h2> <h3 id="_1-css组成"><a href="#_1-css组成" class="header-anchor">#</a> 1.CSS组成</h3> <p>css是层叠样式表的简称，是一种标记语言。css规则由两个主要的部分构成：选择器以及一条或多条声明。每一条声明由一个属性和一个值组成。</p> <h3 id="_2-元素显示模式"><a href="#_2-元素显示模式" class="header-anchor">#</a> 2.元素显示模式</h3> <p>1.<strong>块级元素</strong> div p h1-h6 table tr ul li ol dl dt dd</p> <p>1.独占一整行</p> <p>2.可以设置宽度和高度以及内外边距</p> <p>3.默认宽度是父元素的100%</p> <p>4.块级元素是一个容器，所以里面可以放块级和行内元素</p> <blockquote><p>注意：p,h里面不能放块级元素</p></blockquote> <p>2.<strong>行内元素(内联元素)</strong> a span em i strong b ins u del s</p> <p>1.一行内显示多个</p> <p>2.不能设置宽度和高度，只能设置水平方向的padding和margin</p> <p>3.默认宽度是内容的宽度</p> <p>4.只能包含行内元素和文本</p> <blockquote><p>注意：链接里面不能放链接，a链接里面可以放块级元素，但是建议a转换为块级模式最安全</p></blockquote> <p>3.<strong>行内块级元素</strong> img input td</p> <p>1.在同一行内显示多个</p> <p>2.可以设置宽度和高度以及内外边距</p> <p>3.默认宽度是本身内容的宽度</p> <p>4.可以包含行内元素和块级元素（主要指td）</p> <p>5.中间有默认空隙（由于换行导致的）</p> <p><strong>元素显示模式转换</strong></p> <p>转换为块元素：display: block;</p> <p>转换为行内元素：display: inline;</p> <p>转换为行内块：display: inline-block;</p> <h3 id="_3-css三大特性"><a href="#_3-css三大特性" class="header-anchor">#</a> 3.CSS三大特性</h3> <ol><li><p>层叠性：相同的选择器给设置相同的样式会发生层叠，下面的覆盖上面的。</p> <p>层叠性原则：</p> <ul><li>样式冲突，遵循的原则是就近原则，那个样式离结构近，就执行哪个样式</li> <li>样式不冲突，不会层叠</li></ul></li> <li><p>继承性：子标签会继承父标签的某些样式，如文本颜色和字号。 color  text-  font-  line-height</p></li> <li><p>优先级</p> <p>!important &gt; 行内样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符 &gt; 浏览器默认样式 &gt; 继承</p> <table><thead><tr><th>选择器</th> <th>选择器权重</th></tr></thead> <tbody><tr><td>继承 或者*</td> <td>0000</td></tr> <tr><td>元素/伪元素选择器</td> <td>0001</td></tr> <tr><td>类选择器/伪类选择器</td> <td>0010</td></tr> <tr><td>id选择器</td> <td>0100</td></tr> <tr><td>行内样式 style=&quot;&quot;</td> <td>1000</td></tr> <tr><td>!important</td> <td>无穷大</td></tr></tbody></table> <p>伪元素：::before ::after
伪类：:link :visited :hover :active</p> <p>复合选择器会有权重叠加的问题，权重虽然会叠加，但是永远不会有进位。在数权重时，先看需要修改样式的标签有没有被选中，没有被选中的权重为0，选中的再去数权重。</p></li></ol> <h3 id="_4-css盒子模型"><a href="#_4-css盒子模型" class="header-anchor">#</a> 4.CSS盒子模型</h3> <p>盒子模型组成：content内容、padding内边距、border边框、margin外边距。其中这些组成部分又有left、right、top、bottom</p> <p>对于盒模型，分为标准盒模型（<code>box-sizing: content-box;</code>）和怪异盒模型（<code>box-sizing: border-box;</code>）两种。</p> <p>标准（W3C）盒模型的范围包括margin、border、padding、content，并且宽高只包含content，不包含其他部分。</p> <p>怪异（IE）盒模型的范围包括margin、border、padding、content，和标准盒模型不同的是怪异盒模型的宽高包含了content、padding和border</p> <p><strong>1.border边框</strong></p> <p>​    边框由三部分组成：边框粗细（border-width，单位是px）边框样式（border-style）边框颜色（border-color）</p> <p>​    其中border-style默认值是none，所以不能省略。</p> <p>​    边框样式border-style可以设置如下值：</p> <p>​     none：没有边框即忽略所有边框的宽度（默认值）</p> <p>​     solid：边框为单实线（最为常用）</p> <p>​     dashed：边框为虚线</p> <p>​     dotted：边框为点线</p> <p>边框会额外增加盒子的实际大小。因此我们有两种方案解决:
1. 测量盒子大小的时候,不量边框.
2. 如果测量的时候包含了边框,则需要 width/height 减去边框宽度</p> <p><strong>2.padding:内边距</strong>，即边框与内容之间的距离 会影响盒子大小</p> <p>​    内边距可以有一到四个值。</p> <table><thead><tr><th>取值</th> <th>内容</th></tr></thead> <tbody><tr><td>padding:5px;</td> <td>1个值，代表上下左右都有5像素内边距</td></tr> <tr><td>padding:5px 10px;</td> <td>2个值，代表上下内边距是5像素 左右内边距是10像素</td></tr> <tr><td>padding:5px 10px 20px;</td> <td>3个值，代表上内边距是5像素 左右内边距是10像素 下内边距是20像素</td></tr> <tr><td>padding:5px 10px 20px 30px;</td> <td>4个值，上是5像素 右10像素 下20像素 左30像素 顺时针</td></tr></tbody></table> <p>当一个盒子没有设置宽度，默认宽度是父元素百分之百拿过来的时候，那么padding不会撑大盒子</p> <p>当我们给盒子指定 padding 值之后，发生了 2 件事情：</p> <div class="language- extra-class"><pre><code>1. 内容和边框有了距离，添加了内边距。
2. padding影响了盒子实际大小。也就是说，如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。
</code></pre></div><p>解决方案：</p> <p>​    如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。</p> <p>内边距撑开盒子的好处：使导航栏内字数不同的链接，每个链接之间的距离相同。</p> <p><strong>3.margin:外边距</strong></p> <p>​    margin使块级元素水平居中</p> <p>​    1.必须是块级元素</p> <p>​    2.必须有宽度</p> <p>​    常见的写法，以下三种都可以：</p> <p>​     1)margin-left;auto;  margin-right:auto;</p> <p>​     2)margin:auto;</p> <p>​     3)margin:0 auto;</p> <p>行内元素或行内块元素水平居中用text-align=center;</p> <p><strong>外边距合并</strong></p> <p>使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。</p> <p>主要有两种情况：</p> <p>1.相邻块元素垂直外边距的合并</p> <p>​    当相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们的垂直间距不是margin-bottm与margin-top之和。取较大者这种现象被称为相邻块元素垂直外边距的合并。</p> <p>​    解决方案：尽量只给一个盒子添加margin值。</p> <p>​    只有给垂直方向上的两个盒子设置margin，会发生层叠，取较大的值。（左右边距是相加）</p> <p>2.嵌套块元素垂直外边距的塌陷</p> <p>​    对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p> <p>​    解决方案：</p> <p>​     1.可以为父元素定义上边框。</p> <p>​     2.可以为父元素定义上内边距。</p> <p>​     3.可以为父元素添加overflow:hidden。</p> <p>​     推荐第三种，因为1，2会增加盒子的大小。</p> <p>​    包含塌陷：嵌套关系的盒子，如果给子盒子设置margin-top，那么有可能会把父盒子带跑。</p> <h3 id="_5-css3的盒子模型"><a href="#_5-css3的盒子模型" class="header-anchor">#</a> 5.CSS3的盒子模型</h3> <p>CSS3中可以通过box-sizing来指定盒模型，有两个值：即可指定为content-box，border-box这样计算盒子大小的方式就发生了改变。</p> <p>1.box-sizing:content-box 盒子大小为width + padding + border（以前默认的）</p> <p>2.box-sizing:border-box 盒子大小为width</p> <p>如果盒子模型我们改为了box-sizing:border-box，那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度）</p> <p>CSS3中盒子模型：如果设置为了 border-box</p> <p>实际宽高 = 设置的width/height(包含content + border + padding)</p> <p>组件包括：设置的width/height(包含content + border + padding) + margin</p> <h3 id="_6-传统网页布局的三种方式"><a href="#_6-传统网页布局的三种方式" class="header-anchor">#</a> 6.传统网页布局的三种方式？</h3> <ol><li><p><strong>普通流（标准流）</strong></p> <p>所谓标准流：就是标签按照规定好默认方式排列</p> <p>1.块级元素会独占一行，从上到下顺序排列。 div,hr,p,h1-h6,ul,ol,dl,form,table</p> <p>2.行内元素会按照顺序，从左到右排列，碰到父元素边缘则自动换行。span,a,i,em</p></li> <li><p><strong>浮动</strong></p> <p>为什么需要浮动？可以让多个块级元素一行排列显示。</p> <p>语法：选择器 { float: left/right/none; }</p> <blockquote><p>第一个盒子的文字的基线对准第二个空白盒子的底线（文字的基线对准图片的底线）</p></blockquote> <p>浮动的特点：</p> <p>​    1.浮动之对齐方式</p> <p>​      相邻的浮动的元素会找浮动的元素，在同一行内显示，顶部对齐 要浮动都浮动，要不浮动一个都不浮动</p> <p>​      浮动的元素会脱离标准流，在页面中不占据位置。</p> <p>​      浮动的元素只会影响下面的元素，但是不会影响到文字和图片，表单</p> <p>​       1）上不浮动，下浮动：不浮动的块级元素独占一行，后面的浮动不能在上一行显示</p> <p>​       2）上浮动，下不浮动：上面的覆盖下面的元素内容，因为浮动元素在页面中不占据位置</p> <p>​    2.浮动之父元素对齐</p> <p>​      浮动的元素不会压住父元素的padding，在父元素的padding内部进行浮动。</p> <p>​    3.浮动的显示方式可以更改显示模式</p> <p>​      加了浮动的元素的显示方式基本和行内块级元素一样
导航栏内的浮动</p> <p>​    右浮动时，显示的内容会按照HTML中的顺序从右向左排列，即第一个右浮动在最右边，最后一个在最左边</p> <p><strong>清除浮动</strong>的本质：不是让浮动元素不浮动，只是清除浮动元素造成的影响（例：浮动造成父元素高度为0）</p> <p>清除浮动的策略：</p> <p>1.额外标签法，也称为隔墙法</p> <p>​    在浮动元素的末尾加上一个空标签（块级元素），给他加上clear:both;属性</p> <p><code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></p> <p>​    缺点：加上额外的标签，结构化较差</p> <p>​    语法：</p> <p>​    选择器 { clear:属性值; }</p> <p>​    属性值        描述</p> <p>​    left          不允许左侧有浮动元素（清除左侧浮动的影响）</p> <p>​    right         不允许右侧有浮动元素（清除右侧浮动的影响）</p> <p>​    both          同时清除左右两侧浮动的影响</p> <p>2.使用overflow清除浮动。</p> <p>​    overflow:hidden;溢出隐藏</p> <p>​    overflow:scroll;添加滚动条</p> <p>​    overflow:auto;自动判断是否添加滚动条</p> <p>​    overflow:visible;默认值</p> <p>​    给父元素添加overflow:hidden;清除浮动</p> <p>​    缺点：溢出隐藏</p> <p>3.伪元素</p> <p>​    元素就是标签 伪元素就是伪标签 不是真的标签</p> <p>​    伪元素添加进来的元素 在html中是不存在的 是通过css加进来的</p> <p>​    伪元素添加进来的是个行内元素</p> <p>​    其中content是必写属性</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">div::before</span> <span class="token punctuation">{</span>  在div内部的最前面
  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">div::after</span> <span class="token punctuation">{</span>  在div内部的最后面
  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>​    伪元素清除浮动</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.clearfix::after</span> <span class="token punctuation">{</span>
   <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>  <span class="token comment">/*可以有值，不会显示出来*/</span>
   <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>
   <span class="token comment">/* 隐藏元素 */</span>
   <span class="token property">height</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
   <span class="token comment">/* 隐藏元素 */</span>
   <span class="token property">visibility</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>
   <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token selector">.clearfix</span> <span class="token punctuation">{</span>
   <span class="token comment">/* 解决ie 67 清除浮动问题 */</span>
   *<span class="token property">zoom</span><span class="token punctuation">:</span>1<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>缺点：ie 67 存在兼容性问题</p> <p>4.双伪元素清除浮动</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.clearfix::before,
.clearfix::after</span> <span class="token punctuation">{</span>
   <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>  <span class="token comment">/*content里不能有值，会显示出来 */</span>
   <span class="token property">display</span><span class="token punctuation">:</span>table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.clearfix::after</span> <span class="token punctuation">{</span>
   <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.clearfix</span> <span class="token punctuation">{</span>
   *<span class="token property">zoom</span><span class="token punctuation">:</span>1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>定位</strong></p> <p>定位组成：定位模式+边偏移</p> <p>定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。</p> <p>定位模式</p> <p>1.position:static; 静态定位 默认值 ，元素出现在正常的流中</p> <p>2.position:relative; 相对定位（自恋型）</p> <p>​    1.相对于自身原来的位置</p> <p>​    2.没有脱离标准流，原来在页面中的位置继续占有，后面的盒子仍然以标准流的方式对它。</p> <p>3.position:absolute; 绝对定位（拼爹型）</p> <p>​    1.没有父元素的情况下，根据浏览器可视区来定位</p> <p>​    2.绝对定位有父元素，但是父元素没有定位，还是根据浏览器可视区来定位</p> <p>​    如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置</p> <p>​    3.绝对定位有父元素，且父元素有定位（非静态），那么根据父元素来定位</p> <p>​    子绝父相：子元素绝对定位，父元素相对定位</p> <p>​    4.绝对定位脱离标准流，在页面中不占据位置</p> <p>​    5.绝对定位可以压住父元素的padding值，在它的边框内定位</p> <p>​    6.绝对定位的显示模式和行内块元素一样，可以加宽高</p> <p>4.固定定位 fixed</p> <p>1.永远根据浏览器可视区定位，不会随着滚动条而滚动</p> <p>2.脱离标准流，在页面中不占据位置</p> <p>3.显示方式基本和行内块元素一样，可以直接设置宽度高度 默认宽度内容大小</p> <p>侧边栏随版心缩放：（不能给父元素body加宽高）</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.left,
.right</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span>fixed<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span>200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">left</span><span class="token punctuation">:</span>50%<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span>-641px<span class="token punctuation">;</span> <span class="token comment">/*版心的一半加自身宽度，刚好贴住版心左侧边缘*/</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">right</span><span class="token punctuation">:</span>50%<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span>-641px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>固定定位小技巧： 固定在版心右侧位置。</p> <p>小算法：</p> <ol><li>让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。</li> <li>让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置
就可以让固定定位的盒子贴着版心右侧对齐了。</li></ol> <p>5.sticky：粘性定位（了解）</p> <p>粘性定位可以被认为是相对定位和固定定位的混合。</p> <p>语法：
选择器 { position:sticky; top:10px; }</p> <p>特点：</p> <p>1.以浏览器的可视窗口为参照点移动元素（固定定位特点）</p> <p>2.粘性定位占有原先的位置（相对定位特点）</p> <p>3.必须添加top,left,right,bottom其中一个才有效</p></li></ol> <h3 id="_7-元素的显示和隐藏"><a href="#_7-元素的显示和隐藏" class="header-anchor">#</a> 7.元素的显示和隐藏</h3> <ol><li><p>display属性用于设置一个元素应如何显示。</p> <p>display:none;隐藏对象</p></li></ol> <p>display:block;除了转换为块级元素之外，同时还有显示元素的意思</p> <div class="language- extra-class"><pre><code>display隐藏元素后，不再占有原来的的位置。
</code></pre></div><ol start="2"><li><p>visibility属性用于指定一个元素应可见还是隐藏。</p> <p>visibility:visible;元素可视</p> <p>visibility:hidden;元素隐藏</p> <p>visibility隐藏元素后，继续占有原来的位置。</p> <p>如果隐藏元素想要原来的位置，就用visibility:hidden;</p> <p>如果隐藏元素不想要原来的位置，就用display:none;(用处更多 重点)</p></li> <li><p>overflow属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度）时，会发生什么。</p> <p>​    属性值       描述
​    visible      不剪切内容也不添加滚动条</p> <p>​    hidden       不显示超过对象尺寸的内容，超出的部分隐藏掉</p> <p>​    scroll       不管超出内容与否，总是显示滚动条</p> <p>​    auto         超出自动显示滚动条，不超出不显示滚动条</p> <p>​    一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。</p> <p>​    但是如果有定位的盒子， 请慎用overflow:hidden 因为它会隐藏多余的部分。</p></li></ol> <h3 id="_8-h5c3"><a href="#_8-h5c3" class="header-anchor">#</a> 8.h5c3</h3> <p>html5</p> <ol><li>html5新增语义化标签，header（标题）、nav（导航）、article（文章）、section（节或段）、aside（侧边栏）、footer（页脚）</li> <li>html5新增多媒体标签audio、video</li> <li>html5新增input类型（type）email、url、date、time、month、week、number、tel、search</li> <li>html5新增表单属性：required必填项、autofocus自动聚焦</li></ol> <p>CSS3</p> <ol><li><p>属性选择器</p></li> <li><p>结构伪类选择器</p></li> <li><p>伪元素选择器</p></li> <li><p>CSS3盒子模型</p></li> <li><p>滤镜 filter:函数(); 将模糊或颜色偏移等图形效果应用于元素</p></li> <li><p>calc()函数; 让你在声明CSS属性值时执行一些计算</p></li> <li><p>transition:过渡，是从一个状态渐渐过渡到另外一个状态</p></li> <li><p>背景渐变：background-image:linear-gradient()线性渐变、径向渐变（radial gradients）</p></li> <li><p>媒体查询@media</p></li> <li><p>2D转化：transform:translate(平移) scale(缩放) rotate(旋转)</p></li> <li><p>3D转化：transform:translateX/Y/Z(平移) scaleX/Y/Z(缩放) rotateX/Y/Z(旋转)</p></li> <li><p>animation动画</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token atrule"><span class="token rule">@keyframes</span> 动画名称</span> <span class="token punctuation">{</span>
	<span class="token comment">/*动画开始时候的样式*/</span>
	<span class="token selector">from</span> <span class="token punctuation">{</span>		
	<span class="token punctuation">}</span>
	<span class="token comment">/*动画结束时候的样式*/</span>
	<span class="token selector">to</span> <span class="token punctuation">{</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让元素调用动画集，调用动画的时候必须设置动画名称和动画时间。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">animation</span><span class="token punctuation">:</span>动画名称move 动画时间1s<span class="token punctuation">;</span>
</code></pre></div><p>一个元素调用多个动画时，中间用逗号隔开。</p> <p>百分比动画是相对当前动画执行时间的</p> <div class="language-css extra-class"><pre class="language-css"><code> <span class="token comment">/* 百分比是相对当前动画执行时间的 */</span>
<span class="token atrule"><span class="token rule">@keyframes</span> change</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 相当于from */</span>
    <span class="token selector">0%</span> <span class="token punctuation">{</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token selector">50%</span> <span class="token punctuation">{</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token selector">60%</span> <span class="token punctuation">{</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* 相当于结束时间 */</span>
    <span class="token selector">100%</span> <span class="token punctuation">{</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/*调用时*/</span>
<span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">animation</span><span class="token punctuation">:</span> change 10s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>盒子阴影box-shadow</p></li> <li><p>圆角边框border-radius</p> <ul><li>如果只有一个值，表示四个角设置相同的圆角半径</li> <li>如果有两个值，第一个值表示左上角和右下角，第二个值表示右上角和左下角</li> <li>如果有四个值，表示左上角、右上角、右下角、左下角</li></ul></li></ol> <h3 id="_9-为什么使用css-div布局"><a href="#_9-为什么使用css-div布局" class="header-anchor">#</a> 9.为什么使用CSS+DIV布局？</h3> <p>形式与内容分离，大大减少页面代码，提高页面加载速度；</p> <p>结构清晰，有利于SEO优化；</p> <p>缩短改版时间，布局更方便；</p> <p>一次设计，多次使用。</p> <h3 id="_10-实现元素水平垂直居中的几种方式"><a href="#_10-实现元素水平垂直居中的几种方式" class="header-anchor">#</a> 10.实现元素水平垂直居中的几种方式</h3> <p>1.单行文本的居中</p> <p>水平居中：text-align:center;</p> <p>垂直居中：行高等于高，line-height == height</p> <p>2.多行文本的垂直居中</p> <p>1）使用display:table来实现</p> <p>使块级父元素成为一个块级表格（display:table;）设置宽高，并且设置子元素水平居中（text-align:center;）</p> <p>子元素设置成表格单元格（display:table-cell;），并且给子元素表格内容设置为垂直居中显示（vertical-align:middle;）</p> <p>2）使用absolute与transfrom配合实现</p> <p>首先给文本加绝对定位，父元素加相对定位，让元素距离左边和上边为50%，再用transform向左（上）平移自己宽度的50%。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.box p</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3）使用position + margin-left</p> <p>父盒子设置相对定位，子盒子设置绝对定位，并且左移50%，margin-left移动自身宽度的一半。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.dad</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.son</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span> <span class="token comment">/* 自身宽度的一半 */</span>
    <span class="token property">margin-top</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>4）使用tranform + position:fixed</p> <p>将父元素设置为 positon:fixed，然后上下左右都为 0；使其填满整个屏幕；</p> <p>子元素也设置为 positon:fixed，然后上、左各设为 50%；再设置 transform:translate(-50%,-50%)。</p> <p>5）使用position:fixed</p> <p>将父元素设置为 positon:fixed，然后left, bottom, left, right都为 0；使其填满整个屏幕；</p> <p>子元素也设置为 positon:fixed，然后left, bottom, left, right都为 0；margin 设置为 auto，实现水平垂直居中。</p> <p>6）使用absolute定位</p> <p>父元素设置相对定位，子元素绝对定位边偏移设置为0</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.f</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.s</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>7）使用flex实现</p> <p>给父盒子设置display:flex;弹性盒子，并设置在主轴上的对齐方式居中（justify-content: center;），设置在侧轴上的对齐方式也是居中（align-item: center;）</p> <h3 id="_11-实现左边固定-右边自适应布局"><a href="#_11-实现左边固定-右边自适应布局" class="header-anchor">#</a> 11.实现左边固定，右边自适应布局</h3> <p>1）左侧浮动固定宽度，右边盒子overflow:hidden;，使其不与浮动盒子区域重叠，因此会重新计算宽度。</p> <p>2）左侧浮动固定宽度，右边盒子设置margin-left:左侧盒子固定宽度;</p> <p>3）左侧绝对定位且固定宽度，右侧盒子设置margin-left:左侧盒子固定宽度；</p> <p>4）父元素需要设置font-size:0清除默认间距，子元素设置display:inline-block和font-size，左侧宽度需固定，子元素设置vertical-align：top使其顶部对齐，右侧设置 width: calc(100% - 左侧固定宽度);达到自适应</p> <p>5）给父盒子设置display:table;，子盒子设置diplay:table-cell;，并且给左侧盒子设置固定宽度</p> <p>6）给父盒子设置display:flex;，左侧盒子固定宽度，右侧盒子设置flex:1;</p> <h3 id="_12-flex的特性"><a href="#_12-flex的特性" class="header-anchor">#</a> 12.flex的特性？</h3> <p>伸缩布局是用来解决块级元素在水平方向和垂直方向上的布局方式。</p> <p>两端对齐布局（传统）</p> <p>需要精确计算宽度及外边距，会很麻烦</p> <p>两端对齐布局（伸缩布局）</p> <p>自动精确控制对齐，无需计算</p> <p>伸缩布局：</p> <p>1.先给父元素指定为伸缩盒子  display:flex;</p> <p>​    当给一个盒子指定为是伸缩盒子时，这个盒子就自动的具有了主轴和侧轴，并且主轴和侧轴的关系是垂直关系</p> <p>​    主轴：默认是水平方向</p> <p>​    侧轴：默认是垂直方向</p> <p>​    方向：主轴默认是从左到右，侧轴默认是从上到下</p> <p>2.调整主轴方向 flex-direction</p> <p>​    row：水平方向，从左到右，默认值</p> <p>​    column：垂直方向，从上到下</p> <p>​    row-reverse：水平方向，反转，从右到左</p> <p>​    column-reverse：垂直方向反转，从下到上</p> <p>3.主轴方向对齐，可以调整元素在主轴方向上的对齐方式 justify-content</p> <p>​    flex-start：起始点对齐</p> <p>​    flex-end：结束点对齐</p> <p>​    center：居中对齐</p> <p>​    space-around：环绕对齐，空白间隙平均分配到每个子元素两端</p> <p>​    space-between：两端对齐，空白间隙平均分配到每两个子元素中间</p> <p>4.侧轴方向对齐方式 align-items （单行）</p> <p>​    flex-start：侧轴起始点对齐</p> <p>​    flex-end：侧轴结束点对齐</p> <p>​    center：侧轴居中对齐</p> <p>​    stretch：子元素侧轴拉伸对齐，子元素没有设置高度的情况下，会将子元素拉伸到与父元素一样高</p> <p>5.控制是否换行 flex-wrap</p> <p>​    nowrap：不换行，会自动缩小子元素的宽度，使其在一行显示</p> <p>​    wrap：换行</p> <p>6.align-content 堆栈排列，可对应用flex-wrap:wrap后产生的换行进行控制，对独立行进行调整，垂直方向上（多行）</p> <p>​    flex-start：起始点对齐</p> <p>​    flex-end：结束点对齐</p> <p>​    center：居中对齐</p> <p>​    space-between：两端对齐</p> <p>​    space-around：以行为单位环绕对齐</p> <p>​    stretch：拉伸对齐，默认</p> <p>7.flex-flow:column wrap;是flex-direction和flex-wrap的简写形式</p> <p>8.flex作为属性值是给父元素设置的，作为独立的属性是给子元素的，例 li { flex:1; }</p> <p>​    flex：控制子元素伸缩比例，分配的是剩余空间，不指定flex属性，则不参与伸缩分配</p> <p>9.align-self 同align-items可覆盖父元素设置的align-items，给子元素设置，可单独修改某个子元素的位置</p> <p>​    ul { align-items:center; }</p> <p>​    li { align-self:flex-start; }</p> <p>​    包括flex-start,flex-end,center,stretch</p> <p>10.order控制子元素的顺序，默认是0</p> <p>​    li { order:1;} 子元素按照数字先后顺序排列</p> <h3 id="_13-px、em和rem的区别"><a href="#_13-px、em和rem的区别" class="header-anchor">#</a> 13.px、em和rem的区别？</h3> <p>px是基本的像素单位。</p> <p>em是相对于父元素的字体大小来说的，1em表示父元素的一个文字大小。</p> <p>rem是相对于html的字体大小来说的，1rem表示html定义的一个文字大小。</p> <p>rem的优点是可以通过修改html里面的文字大小来改变页面中元素的大小可以整体控制。</p> <h3 id="_14-应用rem实际开发的方案"><a href="#_14-应用rem实际开发的方案" class="header-anchor">#</a> 14.应用rem实际开发的方案</h3> <p>方案一：less+rem+媒体查询，需要自己写公共样式并且划分屏幕尺寸范围。</p> <p>方案二：flexible.js+rem  <strong>推荐使用</strong></p> <p>两种方案的对比：</p> <ul><li><p>相同：都是对font-size实现控制，1rem（基础块）变化，实现等比效果；</p></li> <li><p>不同：</p></li></ul> <p>​		rem+媒体查询+less：通过设置不同的档位下，设置不同的1rem值；效果为阶梯式变化；</p> <p>​		flexible.js+rem：通过JS设置不同的1rem值，效果为连续变化；这个看起来更为连贯，适配任何屏幕。</p> <h3 id="_15-不使用框架如何写响应式布局"><a href="#_15-不使用框架如何写响应式布局" class="header-anchor">#</a> 15.不使用框架如何写响应式布局</h3> <p>使用媒体查询@media指定在某个屏幕范围内显示对应的样式。</p> <div class="language-css extra-class"><pre class="language-css"><code>// ipad
<span class="token atrule"><span class="token rule">@media</span> <span class="token keyword">only</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 415px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 1024px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
    <span class="token selector">// ipad端下的样式
    html</span> <span class="token punctuation">{</span>
        <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 

// 移动端 320px~414px
<span class="token atrule"><span class="token rule">@media</span> <span class="token keyword">only</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 320px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span>414px<span class="token punctuation">)</span></span><span class="token punctuation">{</span>
    // 移动端屏幕中的css样式
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_16-表现与数据分离、web语义化的理解"><a href="#_16-表现与数据分离、web语义化的理解" class="header-anchor">#</a> 16.表现与数据分离、web语义化的理解</h3> <p><strong>什么是表现与数据分离？</strong></p> <p>一是前后端分离，所有数据都是后端通过AJAX发送给前端，前端负责展现页面，后端负责提供数据。</p> <p>二是前端页面展现与数据处理分离，也就是在前端处理数据的过程中，处理DOM的代码与处理数据的代码要区分开，不能混在一起，这样改起来不会牵连太多。</p> <p><strong>表现与数据分离有什么好处？</strong></p> <p>模块化 –&gt; 容易测试 –&gt; 降低bug频率</p> <p>适用场景：</p> <p>项目具有明显的数据需求，比如要与很多Service交互，业务流程复杂，表单很多</p> <p><strong>什么是web语义化？</strong></p> <p>web语义化是指使用恰当语义的html标签、class类名等，让页面具有良好的结构和含义，使得人和机器都能快速理解网页内容。</p> <p><strong>web语义化有什么意义？</strong></p> <p>去掉或者丢失样式时可以让页面呈现清晰的结构；</p> <p>有利于seo，和搜索引擎建立良好沟通，有利于爬虫抓取更多有效信息；</p> <p>方便其他设备解析（比如屏幕阅读器、移动设备等）；</p> <p>便于团队开发和维护，语义化更具可读性，是下一代web技术的重要方向。</p> <p><strong>如何实现web语义化？</strong></p> <p>可以使用h1~h6、p、table、ul、ol等具有语义的标签，以及使用html5新增的一些语义化标签，如header、footer、nav、section等替代div，以此来实现语义化。</p> <h3 id="_17-使用setinterval-实现倒计时效果"><a href="#_17-使用setinterval-实现倒计时效果" class="header-anchor">#</a> 17.使用setInterval()实现倒计时效果</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>djs<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>倒计时<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">var</span> djs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'djs'</span><span class="token punctuation">)</span>
    djs<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">6</span>
        <span class="token keyword">var</span> time <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            i<span class="token operator">--</span>
            djs<span class="token punctuation">.</span>innerText <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">'秒'</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                window<span class="token punctuation">.</span><span class="token function">clearInterval</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>
                djs<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'倒计时'</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="_18-dom文档加载的步骤"><a href="#_18-dom文档加载的步骤" class="header-anchor">#</a> 18.DOM文档加载的步骤</h3> <ol><li>解析HTML结构</li> <li>加载外部脚本和样式表文件</li> <li>解析并执行脚本代码</li> <li>DOM树构建完成。// DOMContentLoaded</li> <li>加载图片等外部文件</li> <li>页面加载完毕。// load</li></ol> <h3 id="_19-谈谈你对回流和重绘的理解"><a href="#_19-谈谈你对回流和重绘的理解" class="header-anchor">#</a> 19.谈谈你对回流和重绘的理解</h3> <p>什么是回流？</p> <p>当一个元素自身的宽高、布局、显示或隐藏，或元素内部的文字结构发生变化，导致需要重新构建页面的时候，就产生了回流。</p> <p>什么是重绘？</p> <p>当一个元素自身的宽高、布局、及显示或隐藏没有改变，而只是改变元素的外观风格的时候，就产生了重绘。</p> <p>什么时候会进行回流？</p> <ul><li>添加或删除可见的DOM元素的时候</li> <li>元素的位置发生改变</li> <li>元素的尺寸发生改变</li> <li>内容改变</li> <li>页面第一次渲染的时候</li></ul> <p>什么时候会进行重绘？</p> <p>修改元素的一些CSS样式时，例：color、background、background-size、visibility、box-shadow</p> <p>如何减少和避免重排（回流）？</p> <p>回流（Reflow）的成本比重绘（Repaint）的成本高得多的多。一个节点的回流很可能导致子节点，甚至父节点以及兄弟节点的重排。在一些高性能的电脑上也许还没什么，到那时如果重排发生在手机上，那么这个过程是延慢加载和耗电的。</p> <ol><li>使用<strong>transform</strong>代替top、left，因为使用transform页面不会出现回流现象</li> <li>不要使用<strong>table</strong>来进行布局，因为一个小改动就会导致整个table的重新布局</li> <li>不要逐条变更DOM的样式，应封装在一个style对象中赋值给DOM的样式属性，或者添加一个类，样式都在类中改变。</li> <li>可以使用absolute脱离文档流</li> <li>使用display:none，不使用visibility，也不要改变它的z-index。</li> <li>避免频繁操作DOM，创建一个documentFragment，在他上面应用所有DOM操作，最后再把他添加到文档中</li></ol> <p>DocumentFragment 表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow)，且不会导致性能等问题。把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment自身，而是它的所有子孙节点。这使得 DocumentFragment 成了有用的占位符，暂时存放那些一次插入文档的节点。</p> <h3 id="_20-页面导入时-使用link和-import有什么区别"><a href="#_20-页面导入时-使用link和-import有什么区别" class="header-anchor">#</a> 20.页面导入时，使用link和@import有什么区别</h3> <p>页面中使用CSS的方式有3中：行内样式（定义style属性值）、内嵌式（style标签调用）和外链式，其中外链式有两种：link标签引入和@import导入，两者都是外部引用CSS的方式，但是存在一定的区别：</p> <ol><li>从属关系：link是标签，@import是CSS提供的</li> <li>加载差异：link，结构和样式同时加载；而@import先加载结构，后加载样式</li> <li>兼容性：link没有兼容问题，@import不兼容ie5以下的浏览器</li> <li>可操作性：link可以通过JS操作dom插入link标签改变样式，而@import不能</li></ol> <h3 id="_21-简述src和href的区别"><a href="#_21-简述src和href的区别" class="header-anchor">#</a> 21.简述src和href的区别</h3> <p>src，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置，用于替换当前元素。</p> <p>href，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于在当前文档和引用资源之间确立关系。</p> <h3 id="_22-响应式布局有哪些实现方式-什么是响应式设计-响应式设计的基本原理是什么"><a href="#_22-响应式布局有哪些实现方式-什么是响应式设计-响应式设计的基本原理是什么" class="header-anchor">#</a> 22.响应式布局有哪些实现方式？什么是响应式设计？响应式设计的基本原理是什么？</h3> <p>响应式布局的实现方式：</p> <ol><li>百分比布局，但是无法对字体，边框等比例缩放</li> <li>弹性盒子布局 display:flex</li> <li>rem布局，1rem=html的font-size值的大小</li> <li>CSS3媒体查询 <code>@media screen and(max-width: 750px){}</code></li> <li>vw + vh</li> <li>使用一些框架（bootstrap, vant）</li></ol> <p>什么是响应式设计：响应式网站设计是一个网站能够兼容多个终端，智能地根据不同设备环境进行相对应的布局。</p> <p>响应式设计的原理：基本原理是通过媒体查询检测不同的设备屏幕尺寸设置不同的CSS样式，页面头部必须有meta声明的。</p> <h3 id="_23-元素的alt和title有什么异同"><a href="#_23-元素的alt和title有什么异同" class="header-anchor">#</a> 23.元素的alt和title有什么异同</h3> <p>不同点：元素的alt是表示图片加载失败显示的文本内容，而title是表示鼠标悬停图片时显示的文本内容。</p> <p>相同点：在alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。</p> <h3 id="_24-动画实现div盒子从屏幕左边移动到屏幕右边"><a href="#_24-动画实现div盒子从屏幕左边移动到屏幕右边" class="header-anchor">#</a> 24.动画实现div盒子从屏幕左边移动到屏幕右边</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">*</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
            <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.box</span> <span class="token punctuation">{</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>box<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
        <span class="token comment">// 1.获取dom元素</span>
        <span class="token keyword">var</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.box'</span><span class="token punctuation">)</span>
        <span class="token comment">// 2.水平方向移动距离 = 网页可视区宽度 - 元素自身的宽度</span>
        <span class="token keyword">var</span> moveWidth <span class="token operator">=</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>offsetWidth <span class="token operator">-</span> box<span class="token punctuation">.</span>offsetWidth
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>box<span class="token punctuation">,</span>moveWidth<span class="token punctuation">)</span>
        <span class="token comment">// 3.触发dom元素的点击事件，水平移动并设置过渡</span>
        box<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 水平移动</span>
            box<span class="token punctuation">.</span>style<span class="token punctuation">.</span>transform <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">translateX(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>moveWidth<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px)</span><span class="token template-punctuation string">`</span></span>
            <span class="token comment">// 过渡效果</span>
            box<span class="token punctuation">.</span>style<span class="token punctuation">.</span>transition <span class="token operator">=</span> <span class="token string">'all 2s'</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="第二部分-javascript"><a href="#第二部分-javascript" class="header-anchor">#</a> 第二部分：JavaScript</h2> <h3 id="_1-数据类型"><a href="#_1-数据类型" class="header-anchor">#</a> 1.数据类型</h3> <p>1.简单数据类型</p> <p>数字类型Number</p> <p>字符串类型String</p> <p>布尔类型Boolean</p> <p>undefined类型（未定义）</p> <p>对空（null）</p> <p>Symbol（Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值）</p> <p>2.复杂数据类型</p> <p>对象（Object）</p> <p>包括：数组（Array）、函数（Function）</p> <h3 id="_2-类型检测"><a href="#_2-类型检测" class="header-anchor">#</a> 2.类型检测</h3> <ol><li><p>typeof：适合基本类型及function检测，遇到null失效（typeof检测null返回的也是object）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token number">1</span>
<span class="token string">&quot;number&quot;</span>

<span class="token keyword">typeof</span> <span class="token string">'abc'</span>
<span class="token string">&quot;string&quot;</span>

<span class="token keyword">typeof</span> <span class="token boolean">true</span>
<span class="token string">&quot;boolean&quot;</span>

<span class="token keyword">typeof</span> <span class="token keyword">null</span>
<span class="token string">&quot;object&quot;</span>

<span class="token keyword">typeof</span> <span class="token keyword">undefined</span>
<span class="token string">&quot;undefined&quot;</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">typeof</span> fn
<span class="token string">&quot;function&quot;</span>

<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token string">&quot;object&quot;</span>

<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token string">&quot;object&quot;</span>
</code></pre></div></li> <li><p>Object.prototype.toString.call(检测对象)：<strong>可以用来准确地检测所有数据类型</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Number]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Null]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Undefined]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Boolean]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object String]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Object]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Array]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Function]&quot;</span>
</code></pre></div></li> <li><p>instanceof适合自定义对象和原生对象检测，用于判断对象是不是通过某个构造函数创建的（不能用来检测基本数据类型）。</p> <p>instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的原型链上。如果在，则返回true；如果不在，则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
add <span class="token keyword">instanceof</span> <span class="token class-name">Function</span>
<span class="token comment">//true</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span>
<span class="token comment">//true</span>

<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
<span class="token comment">//true</span>
</code></pre></div></li> <li><p>constructor：指向对象的构造函数，似乎完全可以应对基本数据类型和引用数据类型，但如果声明了一个构造函数，并且把它的原型指向了Array的原型，所以这种情况下，constructor也显得力不从心。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Boolean <span class="token comment">// true</span>
<span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> String <span class="token comment">// true</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array <span class="token comment">// true</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function <span class="token comment">// true</span>
<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token comment">// true</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number <span class="token comment">// true</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
fn<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Array<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div></li></ol> <h3 id="_3-强制类型转换"><a href="#_3-强制类型转换" class="header-anchor">#</a> 3.强制类型转换</h3> <ol><li><p>转数字类型</p> <p>Number(变量)</p> <p>parseInt(变量)</p> <p>parseFloat(变量)</p></li> <li><p>转字符串类型</p> <p>变量.toString()</p> <p>String(变量)</p></li> <li><p>转布尔类型</p> <p>Boolean(变量)</p></li></ol> <p>注意：null、undefined没有.toString()方法</p> <h3 id="_4-new操作符具体干了什么"><a href="#_4-new操作符具体干了什么" class="header-anchor">#</a> 4.new操作符具体干了什么？</h3> <ol><li>创建一个空对象，</li> <li>修改this的指向，使其指向新建的对象，并且执行构造函数</li> <li>为新对象添加一个<code>__proto__</code>属性，使其指向构造函数的prototype属性</li> <li>将这个新对象返回出去</li></ol> <h3 id="_5-怎么改变普通函数的this指向"><a href="#_5-怎么改变普通函数的this指向" class="header-anchor">#</a> 5.怎么改变普通函数的this指向</h3> <p>call()和apply()会调用函数，并且改变函数内部的this指向。</p> <p>call()和apply()传递参数的格式不一样，call()传递参数的方式是零散的（arg1,arg2,...），apply()传递参数以数组的方式（[arg1,arg2,...]）</p> <p>bind()不会调用函数，可以改变函数内部this指向</p> <p>主要应用场景：</p> <p>1.call()经常做继承</p> <p>2.apply()经常跟数组有关，比如借助于数学对象（Math）实现数组最大值最小值</p> <p>3.bind()不调用函数，但是还想改变this指向。比如定时器内部的this指向</p> <h3 id="_6-如何消除数组里面的重复元素"><a href="#_6-如何消除数组里面的重复元素" class="header-anchor">#</a> 6.如何消除数组里面的重复元素</h3> <p>第一种：排序后比较法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arrNew <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//a.排序</span>
arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token operator">-</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//b.遍历这个排序后的数组，始终把当前项和他后面的这一项进行比较</span>
<span class="token comment">//如果相等就说明重复了，就不添加当前项，如果不等，就添加</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token operator">!=</span>arr<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        arrNew<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//[10, 20, 30, 40, 50]</span>
</code></pre></div><p>第二种：利用对象属性不重复的特性</p> <div class="language-js extra-class"><pre class="language-js"><code>原理：对象是不能有重复的属性的
如果对象有这个属性，就取这个对象的属性，如果没有这个属性，就给对象添加
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arrNew <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//遍历arr</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        arrNew<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//[10, 20, 30, 50, 40]</span>
</code></pre></div><p>第三种：使用ES6中的集合Set</p> <div class="language-js extra-class"><pre class="language-js"><code>Set是一种数据类型，和数组差不多，但是区别是Set不能放重复的项
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Set(5) {10, 20, 30, 50, 40}</span>
<span class="token comment">//...展开运算符不仅可以展开数组，还可以展开对象</span>
<span class="token keyword">var</span> arrNew <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>set<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Array.from(set)可以将伪数组转化为数组</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//[10, 20, 30, 50, 40]</span>
</code></pre></div><h3 id="_7-怎么判断一个方法是在原型上还是在对象上"><a href="#_7-怎么判断一个方法是在原型上还是在对象上" class="header-anchor">#</a> 7.怎么判断一个方法是在原型上还是在对象上</h3> <p>对象.hasOwnProperty()函数用于指示一个对象自身（不包括原型链）是否具有指定名称的属性。如果有，返回true，否则返回false。例：如果某个属性是构造函数原型对象上的属性，但不是实例对象的属性，那么使用 实例化对象.hasOwnProperty() 返回false.</p> <p>(属性 in 对象) 不管属性是原型对象的还是实例对象的，只要存在就返回true，否则返回false。</p> <p>!obj.hasOwnProperty(属性) &amp;&amp; (属性 in obj) 判断一个方法或属性在原型上还是在实例对象上。如果在原型对象上，那么hasOwnProperty()返回false，取反后为true，那么上述公式是true，即原型对象上的属性或方法返回true，实例对象上的属性或方法返回false</p> <h3 id="_8-遍历对象的属性、属性值方法"><a href="#_8-遍历对象的属性、属性值方法" class="header-anchor">#</a> 8.遍历对象的属性、属性值方法</h3> <p>for(item in 对象){}遍历对象</p> <p>Object.values(对象)返回一个给定对象自身的所有可枚举属性值的数组。</p> <p>Object.keys(对象)返回由一个给定对象的自身可枚举属性组成的数组，数组属性名的顺序和正常循环遍历该对象时返回的顺序一致。</p> <h3 id="_9-创建对象的方式"><a href="#_9-创建对象的方式" class="header-anchor">#</a> 9.创建对象的方式</h3> <p>1.通过字面量的方式创建对象（创建单个对象）</p> <p>var 对象名称 = {}</p> <p>2.通过内置的构造函数创建对象（创建单个对象）</p> <p>var 自定义对象名 = new Object()</p> <p>3.通过工厂方式创建对象（创建多个对象）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token parameter">username</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    stu<span class="token punctuation">.</span>name <span class="token operator">=</span> username
    <span class="token keyword">return</span> stu
<span class="token punctuation">}</span>
<span class="token keyword">var</span> zs <span class="token operator">=</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">)</span>
</code></pre></div><p>4.通过自定义构造函数创建对象（创建多个对象）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token parameter">usename<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> usename
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token keyword">var</span> zs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_10-深拷贝浅拷贝的区别"><a href="#_10-深拷贝浅拷贝的区别" class="header-anchor">#</a> 10.深拷贝浅拷贝的区别</h3> <p>浅拷贝：只拷贝最外面的一层。</p> <p>对于简单数据类型拷贝的是值。</p> <p>对于对象或数组等引用数据类型仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为 浅拷贝。</p> <p>深拷贝：遇到数组或对象再拷贝一次</p> <p>深拷贝不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上,所以对一个对象的修改并不会影响另一个对象。</p> <h3 id="_11-undefined和null的区别"><a href="#_11-undefined和null的区别" class="header-anchor">#</a> 11.undefined和null的区别</h3> <p>相同点：</p> <ul><li>在if语句中null和undefined都会转为false，两者用相等运算符比较也是相等</li> <li>null和undefined都是基本数据类型，这两个基本数据类型分别都只有一个值，就是undefined和null</li></ul> <p>null表示“没有对象”，即该处不应该有值。典型用法是：</p> <p>（1） 作为函数的参数，表示该函数的参数不是对象。</p> <p>（2） 作为对象原型链的终点。</p> <p>undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p> <p>（1）变量被声明了，但没有赋值时，就等于undefined。</p> <p>（2）调用函数时，应该提供的参数没有提供，该参数等于undefined。</p> <p>（3）对象没有赋值的属性，该属性的值为undefined。</p> <p>（4）函数没有返回值时，默认返回undefined。</p> <h3 id="_12-原型链"><a href="#_12-原型链" class="header-anchor">#</a> 12.原型链</h3> <p>原型链：就是由原型（__ proto __）所串联起来的链状结构。</p> <p>作用：提供一个成员的查找机制，或者查找规则。</p> <p>当访问一个对象的属性或方法时，首先查找这个对象自身有没有该属性或方法。如果没有找到，就沿着原型链查找它的原型对象（也就是<code>__proto__</code>指向的prototype原型对象）。如果还没有找到就查找原型对象的原型（Object的原型对象），以此类推，直到找到null为止。</p> <p><img src="/assets/img/prototypeChain.83f70263.png" alt=""></p> <h3 id="_13-闭包"><a href="#_13-闭包" class="header-anchor">#</a> 13.闭包</h3> <p>闭包（closure）指有权访问另一个函数作用域中的变量的函数。简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。</p> <p>内部函数对外部函数的变量有了引用关系--闭包就是这时产生的。每次对外部函数调用，都会产生一次闭包。</p> <p>闭包作用：一是可以读取函数内部的变量（延伸变量的作用范围），二是让这些变量的值始终保存在内存中，不会在函数调用后被自动清除。</p> <p>闭包的缺点及解决办法：</p> <p>1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p> <p>2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公共方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。</p> <h3 id="_14-原生js发送ajax请求的流程"><a href="#_14-原生js发送ajax请求的流程" class="header-anchor">#</a> 14.原生js发送ajax请求的流程</h3> <p>ajax是一种异步通信的方法，从服务器获取数据，达到局部刷新页面的效果。</p> <p>使用XMLHttpRequest对象发送get请求</p> <p>1.创建xhr对象</p> <p>2.调用xhr.open('GET','url?参数=值&amp;参数=值')函数，设置请求方式、接口地址、同步异步（true/false）</p> <p>3.调用xhr.send(null)函数，用于发送请求，发送GET请求时，xhr.send()没有参数</p> <p>4.监听xhr.onreadystatechange事件，获取接口返回的结果</p> <p>使用XMLHttpRequest对象发起POST请求</p> <p>1.创建xhr对象</p> <p>2.调用xhr.open()函数，设置请求方式和url</p> <p>3.通过设置请求头xhr.setRequestHander()方法设置content-type属性，'application/x-www-form-urlencoded'告诉接口发送的数据是字符串类型的</p> <p>4.调用xhr.send(参数=值&amp;参数=值...)函数，同时指定要发送的数据，查询字符串格式</p> <p>5.监听xhr.onreadystatechange事件，事件内部使用responseText属性接收结果</p> <p>onreadystatechange事件：</p> <p>readyState每次发生改变时都会触发onreadystatechange事件，0-&gt;1，1-&gt;2，2-&gt;3，3-&gt;4，一共触发4次，所以只能判断1-4这4个值。在该事件函数中可以判断reayState的值，如果等于4，则使用responseText来接收后端返回的数据。</p> <table><thead><tr><th><strong>值</strong></th> <th><strong>状态</strong></th> <th><strong>描述</strong></th></tr></thead> <tbody><tr><td>0</td> <td>UNSENT</td> <td>XMLHttpRequest 对象已被创建，但尚未调用 open方法。</td></tr> <tr><td>1</td> <td>OPENED</td> <td>open() 方法已经被调用。</td></tr> <tr><td>2</td> <td>HEADERS_RECEIVED</td> <td>send() 方法已经被调用，响应头也已经被接收。</td></tr> <tr><td>3</td> <td>LOADING</td> <td>数据接收中，此时 response 属性中已经包含部分数据。</td></tr> <tr><td>4</td> <td>DONE</td> <td>Ajax 请求完成，这意味着数据传输已经彻底完成或失败。</td></tr></tbody></table> <h3 id="_15-javascript本地存储方式"><a href="#_15-javascript本地存储方式" class="header-anchor">#</a> 15.javaScript本地存储方式</h3> <p>javaScript有三种数据存储方式，分别是：</p> <p>sessionStorage、localStorage、cookie</p> <p>相同点：都保存在浏览器端</p> <p>不同点：</p> <p>①传递方式不同</p> <p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。<code>cookie</code>数据还有路径（<code>path</code>）的概念，可以限制<code>cookie</code>只属于某个路径下，<code>sessionStorage</code> 和 <code>localStorage</code> 不会自动把数据发给服务器，仅在本地保存。</p> <p>②数据大小不同</p> <p>存储大小限制也不同，cookie数据不能超过4k，因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</p> <p>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p> <p>③数据有效期不同</p> <p>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</p> <p>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</p> <p>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</p> <p>④作用域不同</p> <p>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</p> <p>localStorage 在所有同源窗口中都是共享的；</p> <p>cookie也是在所有同源窗口中都是共享的。</p> <h3 id="_16-作用域和作用域链"><a href="#_16-作用域和作用域链" class="header-anchor">#</a> 16.作用域和作用域链</h3> <p>作用域：作用域是定义变量的区域，主要分为全局作用域和局部作用域</p> <p>全局作用域：JS中最外层的区域称为全局作用域，在全局作用域中定义的变量称为全局变量</p> <p>局部作用域：函数内部的区域被称为局部作用域，在局部作用域中定义的变量称为局部变量</p> <p>全局变量和局部变量的区别：</p> <ol><li>全局变量可以在任何作用域中被直接使用</li> <li>局部变量只能在当前作用域中使用</li> <li>如果想要使用局部变量的值，那么只能通过返回值来使用</li></ol> <p>作用域链：作用域和作用域链接到一块，形成一个链状结构。</p> <p>作用域链的作用：当程序在执行代码的时候，先在当前作用域中执行，如果当前作用域没有，那么程序会沿着作用域链向上一级查找执行代码。</p> <h3 id="_17-事件流、事件委托、如何阻止事件冒泡-如何阻止默认事件"><a href="#_17-事件流、事件委托、如何阻止事件冒泡-如何阻止默认事件" class="header-anchor">#</a> 17.事件流、事件委托、如何阻止事件冒泡？如何阻止默认事件？</h3> <p>事件流：事件触发后的三个阶段（捕获阶段--目标阶段--冒泡阶段）。只要发生事件就会有一个流程，即程序执行的过程。</p> <p>注意：在事件发生后，这三个阶段是始终存在的，顺序：先捕获，到达目标，再冒泡。但是再触发后，针对捕获和冒泡仅仅启用一个。</p> <p>捕获：从document一级一级的往下查找，直到找到目标</p> <p>目标：找到目标对象后，根据事件，对事件进行处理，事件处理程序</p> <p>冒泡：对事件处理结束后，一级一级的退出，直到退出document</p> <p>事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如click事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到document/window，冒泡过程结束。</p> <p>阻止事件冒泡：</p> <div class="language-js extra-class"><pre class="language-js"><code>box<span class="token punctuation">.</span><span class="token function-variable function">onmouseover</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 阻止冒泡</span>
    event <span class="token operator">=</span> event <span class="token operator">||</span> window<span class="token punctuation">.</span>event
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">&amp;&amp;</span> event<span class="token punctuation">.</span>stopPropagation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        event<span class="token punctuation">.</span>cancelBubble <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>事件捕获，与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。事件捕获的概念下发生click事件的顺序应该是：document -&gt; html -&gt; body -&gt; div -&gt; p。</p> <p>阻止浏览器默认行为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 阻止浏览器默认行为</span>
<span class="token keyword">function</span> <span class="token function">stopDefault</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 阻止浏览器默认动作（W3C）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>preventDefault<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// IE中阻止函数器默认动作的方式</span>
        window<span class="token punctuation">.</span>event<span class="token punctuation">.</span>returnValue <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>事件委托（事件代理）：把子孙元素的事件注册，完全交给子孙元素的上级元素代理。</p> <p>事件委托给父元素注册事件，父元素内部的所有子孙元素可以共享父元素的事件。</p> <p>如何实现事件委托？</p> <ol><li>给子孙的上级注册事件，就是把下级元素需要注册的事件委托给上级</li> <li>在事件处理过程中，通过 事件对象.target 获取最先触发的元素</li> <li>可以通过 事件对象.target 的nodeName属性检测最先触发的是否是指定元素（节点.nodeName返回节点名称，元素节点返回值是大写的标签名，文本节点返回值是#text）</li></ol> <p>事件委托的原理：</p> <ul><li>关键：事件对象.target；可以获取最先触发的元素</li> <li>原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。</li></ul> <p>事件委托的作用：</p> <ol><li>减少事件的绑定，节省内存</li> <li>上级元素可以代理未来新动态添加的元素</li></ol> <p>解释：当多个元素触发同一种类型的事件，并且做同样的操作，以往的选择以遍历的方式给每个元素逐个添加事件处理函数，但是函数是一种特殊的数据，每次创建一个函数就会在内存中开辟一个空间，这样多个相同操作的函数就会造成内存空间的浪费。</p> <p>于是，就产生了事件委托，事件委托就是将子元素需要执行的事件处理函数委托给父元素，每次子元素触发事件的时候借助父元素注册事件中的事件对象的target属性，获取最先触发的元素（就是需要做操作的子元素），然后子元素进行相关操作。在触发事件过程中我们很可能点击到不需要执行相关操作的元素，但是它也触发了事件，这时就需要对接收到的目标对象进行判断，通过节点的nodeName属性，判断目标元素是否是我们想要操作的元素。</p> <p>而且，通过事件委托，新添加的元素也可以调用父元素定义的函数。逐个定义函数的方式不能使新添加的元素触发事件。</p> <h3 id="_18-js继承的几种方式"><a href="#_18-js继承的几种方式" class="header-anchor">#</a> 18.js继承的几种方式</h3> <ol><li><p><strong>构造函数继承</strong></p> <p>实现：Father.call(this)，创建子类实例时调用Father构造函数，于是子类的每个实例都会将父类中的属性复制一份。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span>
    <span class="token comment">// 实例方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 原型方法</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 继承Father</span>
    <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Jery'</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>优点：</p> <ul><li>创建子类实例时，可以向父类传递参数</li> <li>可以实现多继承（call多个父类对象）</li></ul> <p>缺点：</p> <ul><li>实例并不是父类的实例，只是子类的实例</li> <li>只能继承父类的实例属性和方法，不能继承原型属性和方法</li> <li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li></ul></li> <li><p><strong>原型链继承</strong></p> <p>实现：父类的实例作为子类的原型</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span>
    <span class="token comment">// 实例方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 原型方法</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jery'</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>优点：</p> <ul><li>简单易于实现</li> <li>父类的新增实例属性和方法与原型属性和方法子类都能访问</li></ul> <p>缺点：</p> <ul><li>可以在子类中增加实例属性，如果要新增加原型属性和方法需要在new父类构造函数的后面</li> <li>无法实现多继承</li> <li>创建子类实例时，不能向父类构造函数中传参数。</li></ul></li> <li><p><strong>原型式继承</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span>
    <span class="token comment">// 实例方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 原型方法</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 先封装一个函数容器，用来输出对象和承载继承的原型</span>
<span class="token keyword">function</span> <span class="token function">content</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj <span class="token comment">// 继承了传入的参数</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回函数对象</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> sup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 拿到父类的实例</span>
<span class="token keyword">var</span> sup1 <span class="token operator">=</span> <span class="token function">content</span><span class="token punctuation">(</span>sup<span class="token punctuation">)</span>
</code></pre></div><p>优点：</p> <ul><li>简单易实现</li> <li>不限制调用方式</li></ul> <p>缺点：</p> <ul><li>不能多次继承</li></ul></li> <li><p><strong>组合式继承</strong></p> <p>实现：构造函数继承和原型链继承的组合。用原型链实现对原型属性和方法的继承，借用构造函数技术实现实例属性的继承。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span>
    <span class="token comment">// 实例方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 原型方法</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
</code></pre></div><p>优点：</p> <ul><li>函数可以复用</li> <li>不存在引用属性问题</li> <li>不仅可以继承实例属性和方法，还可以继承原型的属性和方法</li></ul> <p>缺点：</p> <ul><li>由于调用了两次父类，所以产生了两份实例（耗内存）</li></ul></li> <li><p><strong>寄生组合继承</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 父类</span>
<span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">'Tom'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age <span class="token operator">||</span> <span class="token number">18</span>
    <span class="token comment">// 实例方法</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父类原型方法</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 子类</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 继承父类属性</span>
    <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 继承父类方法</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建空类</span>
    <span class="token keyword">let</span> <span class="token function-variable function">Super</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token class-name">Super</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Father</span><span class="token punctuation">.</span>prototype
    <span class="token comment">// 父类的实例作为子类的原型</span>
    <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 修复构造函数指向问题</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>优点：</p> <ul><li>修复了组合继承的缺点</li></ul> <p>缺点：</p> <ul><li>实现较为复杂</li></ul></li> <li><p><strong>ES6中的class继承</strong></p> <p>实现：首先利用class构造一个父类，然后利用extends与super实现子类继承。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token punctuation">}</span>
    <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> eat food</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 继承父类</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 继承父类属性</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 继承父类方法</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>优点：语法简单易懂，操作更方便</p> <p>缺点：并不是所有的浏览器都支持class关键字</p></li></ol> <p>ES5继承和ES6继承的区别：</p> <p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。</p> <p>ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法加到this上面（所以必须先调用super()方法），然后再用子类的构造函数修改this。</p> <p><strong>需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。</strong></p> <h3 id="_19-attribute和property之间的区别是什么"><a href="#_19-attribute和property之间的区别是什么" class="header-anchor">#</a> 19.attribute和property之间的区别是什么？</h3> <p>property是DOM中的属性，是JavaScript里的对象，可以使用元素.属性获取。</p> <p>attribute是HTML标签上的特性，它的值只能够是字符串，不能添加到DOM树上，就不能在后台查看。不能使用 元素.属性 获取，只能通过元素.getAttribute('属性')获取。</p> <h3 id="_20-常用的数组api、字符串api"><a href="#_20-常用的数组api、字符串api" class="header-anchor">#</a> 20.常用的数组API、字符串API</h3> <p>数组API：</p> <ul><li><p>concat()：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p> <p>语法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span> arr3<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>slice()：返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。</p> <p>语法：</p> <div class="language-js extra-class"><pre class="language-js"><code>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">[</span>begin<span class="token punctuation">[</span><span class="token punctuation">,</span> end<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
参数：
  begin 可选
    提取起始处的索引（从 <span class="token number">0</span> <span class="token function">开始），从该索引开始提取原数组元素。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 <span class="token number">0</span> 开始。如果 begin 超出原数组的索引范围，则会返回空数组。
  end 可选
    提取终止处的索引（从 <span class="token number">0</span> 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 <span class="token function">end）。slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>的元素）。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 <span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。如果 end 被省略，则 slice 会一直提取到原数组末尾。如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。
</code></pre></div></li> <li><p>splice()：方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。</p> <p>语法：</p> <div class="language-js extra-class"><pre class="language-js"><code>array<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>start<span class="token punctuation">[</span><span class="token punctuation">,</span> deleteCount<span class="token punctuation">[</span><span class="token punctuation">,</span> item1<span class="token punctuation">[</span><span class="token punctuation">,</span> item2<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// - start：指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。</span>
<span class="token comment">// - deleteCount：可选，整数，表示要移除的数组元素的个数。</span>
<span class="token comment">// - item1,item2,...：可选，要添加进数组的元素，从start位置开始。如果不指定，则 splice() 将只删除数组元素。</span>
</code></pre></div><p>返回值：</p> <p>由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</p></li> <li><p>indexOf()：从前往后遍历数组，获取数组中值x第一次出现对应的索引位置，如果数组中有对应的x值，那么返回该值所在的索引，如果数组中没有对应的x值，那么返回-1</p></li> <li><p>lastIndexOf()：从后往前遍历数组，获取数组中值x第一次出现对应的索引位置，如果数组中有对应的x值，那么返回该值所在的索引，如果数组中没有对应的x值，那么返回-1</p></li> <li><p>every()：测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p> <p>特点：</p> <p>​	1.every方法为数组中的每个元素执行一次函数，直到它找到一个会使函数返回false的元素。如果发现了一个这样的元素，every方法就会立即返回false。否则，函数为每一个元素返回true，every就会返回true。</p> <p>​	2.若收到一个空数组，此方法在一切情况下都会返回true。</p></li> <li><p>some()：遍历数组的同时，检测数组中的元素是否满足指定条件。通俗点讲查找数组中是否有满足条件的元素。</p> <p>特点：</p> <p>​	1.找到第一个满足条件的元素，即返回值为true时，就停止循环</p> <p>​	2.返回值是一个布尔类型的数据，查找到指定的元素返回true，查找不到就返回false.</p> <p>​	3.数组中有至少一个元素通过回调函数的测试就会返回true；所有元素都没有通过回调函数的测试返回值才会为false.</p> <p>​	4.一个空数组进行测试，在任何情况下它返回的都是false.</p></li> <li><p>filter()：遍历数组的同时可以筛选数组中符合条件的值，返回一个新的数组。新数组中的元素是通过检查指定数组中符合条件的所有元素。</p></li> <li><p>map()：遍历数组的同时，通过对每个数组元素执行函数来创建新数组。</p> <p>特点：</p> <p>​	1.不会对没有值的数组元素执行函数。</p> <p>​	2.不会更改原始数组</p> <p>​	3.返回一个新数组</p></li> <li><p>forEach()：对数组的每个元素执行一次给定的函数。</p> <p>语法：</p> <div class="language-js extra-class"><pre class="language-js"><code>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span>currentValue<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">,</span> thisArg<span class="token punctuation">)</span>
参数：
  callback回调函数接收一至三个参数：
    currentValue：数组中正在处理的当前元素。
    index：数组中正在处理的当前元素的索引。
    <span class="token function">array：forEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法正在操作的数组。
  thisArg：当执行回调函数callback时，用作<span class="token keyword">this</span>的值。
</code></pre></div></li> <li><p>includes()：返回一个布尔值，表示某个数组是否包含给定的值，第二个参数表示搜索的位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它的绝对值大于数组长度，则会重置为0开始。</p></li></ul> <p>字符串API：</p> <ul><li><p>split('分隔符')：分割字符串，返回结果是一个数组，并且数组的值是字符串类型。</p></li> <li><p>charAt(索引值)：获取指定位置处的字符，字符串中字符的索引从0开始。</p></li> <li><p>slice(startindex, end)  返回值是截取到的字符串</p> <p>语法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">startindex</span><span class="token operator">:</span>该参数表示从哪个索引开始截取<span class="token punctuation">,</span>必须设置
<span class="token literal-property property">end</span><span class="token operator">:</span>截取的字符串到哪个索引结束<span class="token punctuation">,</span>不包括end所在索引的字符<span class="token punctuation">,</span>可选。如果没有设置end<span class="token punctuation">,</span>默认截取到字符串的末尾
</code></pre></div></li> <li><p>substr(startindex,length)  返回值是截取到的字符串</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">startindex</span><span class="token operator">:</span>该参数表示从哪个索引开始截取字符串<span class="token punctuation">,</span>必须设置
<span class="token literal-property property">length</span><span class="token operator">:</span>要截取的字符串长度是多少<span class="token punctuation">,</span>可选
如果length参数没有设置<span class="token punctuation">,</span>那么默认表示截取到字符串末尾
</code></pre></div></li> <li><p>indexOf(x)：从前往后遍历字符串，获取字符串中值x第一次出现对应的索引位置，如果字符串中有对应的x值，那么返回该值所在的索引，如果字符串中没有对应的x值，那么返回-1</p></li> <li><p>lastIndexOf()：从后往前遍历字符串，获取字符串中值x第一次出现对应的索引位置，如果字符串中有对应的x值，那么返回该值所在的索引，如果字符串中没有对应的x值，那么返回-1</p> <p>注意：
indexOf(x) 和 lastIndexOf()可以设置两个参数，如果设置了第二个参数，代表从该位置起向后（向前）查找</p></li> <li><p>concat()：将两个字符串拼接在一起，返回一个新的字符串</p></li> <li><p>replace('targetElement','element')  只能替换第一次出现的字符</p> <div class="language- extra-class"><pre class="language-text"><code>targetElement:要替换的字符，或着正则表达式
element:替换后的字符
返回值是替换后的字符串,并不改变原来的字符串变量的值
</code></pre></div></li> <li><p>trim()：只能去掉字符串首尾的空白</p></li> <li><p>toUpperCase()：将字符串转换为大写，不影响汉字</p></li> <li><p>toLowerCase()：将字符串转换为小写</p></li></ul> <h3 id="_21-dom事件中的target和currenttarget有什么区别"><a href="#_21-dom事件中的target和currenttarget有什么区别" class="header-anchor">#</a> 21.DOM事件中的target和currentTarget有什么区别？</h3> <p>target在事件流的目标阶段；currentTarget在事件流的捕获、目标及冒泡阶段。只有当事件流处在目标阶段的时候，两个的指向才是一样的，而当处于捕获和冒泡阶段的时候，target指向被单击的对象，而currentTarget指向当前事件活动的对象（注册该事件的对象）（一般为父级）</p> <h3 id="_22-js实现一个简单的倒计时"><a href="#_22-js实现一个简单的倒计时" class="header-anchor">#</a> 22.JS实现一个简单的倒计时</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> remaining_time <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'remaining_time'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token number">6</span>
<span class="token keyword">function</span> <span class="token function">changeTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token operator">--</span>
    remaining_time<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'倒计时'</span> <span class="token operator">+</span> t <span class="token operator">+</span> <span class="token string">'秒'</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">'changeTime()'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">changeTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_23-this的指向问题"><a href="#_23-this的指向问题" class="header-anchor">#</a> 23.this的指向问题</h3> <p>在全局的环境下this是指向window的</p> <p>普通函数调用直接调用中的this会指向window，严格模式下this会指向undefined，执行性函数this指向window，定时器中的this指向window</p> <p>在对象里调用的this，指向调用函数的那个对象</p> <p>在构造函数以及类中的this，构造函数配合new使用，而new关键字会将构造函数中的this指向实例化对象，所以构造函数中的this指向当前实例化的对象</p> <p>方法中的this谁调用就指向谁</p> <p>箭头函数没有自己的this，箭头函数的this在定义的时候，会继承自外层第一个普通函数的this</p> <h3 id="_24-同步和异步"><a href="#_24-同步和异步" class="header-anchor">#</a> 24.同步和异步</h3> <p>同步任务：指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p> <p>异步任务：指的是不进入主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p> <p>对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步任务则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。</p> <p>同步案例：for循环语句、alert()、console.log等js大部分都是同步编程</p> <p>异步案例：定时器、Ajax异步请求、事件绑定等</p> <p>JS代码执行流程：</p> <ol><li>JS在执行代码的时候，先执行同步代码，遇到异步代码，会把它们放到一个队列中，排好队，等所有的同步代码都执行完毕了，然后才会挨个执行异步代码</li> <li>多个异步代码任务同时执行，谁先结束任务不能确定，所以异步代码的结果谁先出来就不一定了</li></ol> <h3 id="_25-什么是设计模式"><a href="#_25-什么是设计模式" class="header-anchor">#</a> 25.什么是设计模式？</h3> <p>设计模式是一套被反复使用的代码，设计经验的总结。使用设计模式是为了重用代码，让代码更容易被他人理解、保证代码可靠性。设计模式让代码变得工程化，设计模式是软件工程的基石。</p> <ol><li>工厂模式，去做同样的事情，实现同样的效果，解决多个相似的问题，这时候需要使用工厂模式</li> <li>发布订阅者模式，通过Object.defineProperty()来劫持各个属性的getter、setter，在数据变动时发布消息给订阅者，触发相应的监听回调。</li> <li>单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li></ol> <h3 id="_26-面向过程、面向对象"><a href="#_26-面向过程、面向对象" class="header-anchor">#</a> 26.面向过程、面向对象</h3> <p>面向过程：面向过程就是分析出解决问题所需要的步骤，通过函数一步一步实现这些步骤，接着依此调用即可。</p> <p>面向对象：面向对象就是把事物分解成为一个个对象（将数据与函数绑定到一起，进行封装），然后由对象之间分工与合作。</p> <p>面向过程</p> <p>优点：性能上它是优于面向对象的，因为类在调用的时候需要实例化，开销过大。</p> <p>缺点：不易维护、复用、扩展</p> <p>面向对象</p> <p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p> <p>缺点：性能比面向过程低。</p> <p>面向过程，按照步骤完成，适用于小项目。</p> <p>面向对象，对象与对象之间合作完成，适用于多人合作大项目。</p> <p>面向对象三大特性：封装、继承、多态</p> <p>封装性：封装就是把抽象出来的数据和对数据的操作封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（成员方法），才能对数据进行操作。</p> <p>继承性：继承可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。</p> <p>多态性：多态是指一个引用（类型）在不同情况下的多种状态。也可以理解成：多态是指通过父类的引用，来调用在不同子类中实现的方法。</p> <h3 id="_27-js如何处理文件流"><a href="#_27-js如何处理文件流" class="header-anchor">#</a> 27.JS如何处理文件流</h3> <p>举例：base64格式编码文件</p> <ol><li>安装<code>js-base64</code>插件</li> <li>使用Base64.atob方法解码base64编码格式文件</li> <li>使用Uint8Array()构造函数创建一个存储解码后数据的数组</li> <li>将解码后的base64数据通过charCodeAt()方法转成二进制编码存储在Uint8Array数组中</li> <li>将二进制编码数组通过<code>new Blob([Uint8Array], {type: 'application/vnd.ms-excel'})</code>转成Blob对象</li> <li>用window.URL.createObjectURL(blob对象)将blob对象转成blob链接</li> <li>使用document.createElement('a')创建一个a标签</li> <li>将blob链接赋值给a标签的href属性，并配置a标签的download属性为文件名</li> <li>利用a标签自带的下载功能把内容下载下来（触发a标签的click事件）</li> <li>最后调用window.URL.revokeObjectURL()方法释放blob链接</li></ol> <h2 id="第三部分-jquery"><a href="#第三部分-jquery" class="header-anchor">#</a> 第三部分：jQuery</h2> <h3 id="_1-jquery的特点"><a href="#_1-jquery的特点" class="header-anchor">#</a> 1.jQuery的特点？</h3> <p>链式编程、隐式迭代</p> <h3 id="_2-如何快速收集form表单数据"><a href="#_2-如何快速收集form表单数据" class="header-anchor">#</a> 2.如何快速收集form表单数据？</h3> <p>1.使用$(form表单).serialize()快速收集表单信息。</p> <p>注意：</p> <ul><li>在使用serialize()收集表单数据时，必须为每个表单元素添加name属性，并且属性值一定要和接口中定义的参数名称相同。</li> <li>通过serialize()获取到的数据是查询字符串的格式，不能用来提交文件。</li></ul> <p>2.使用FormData('form表单dom对象')收集表单数据，必须要给file表单域加name属性，可以上传文件。</p> <h3 id="_3-jquery能做什么"><a href="#_3-jquery能做什么" class="header-anchor">#</a> 3.jQuery能做什么？</h3> <p>jQuery是一套JavaScript库，他简化了使用JavaScript进行网页特效开发的一些复杂性，提供了对常见任务的自动化和复杂任务的简化。</p> <ul><li>获取页面的元素</li> <li>修改页面的外观</li> <li>改变页面大的内容</li> <li>响应用户的页面操作</li> <li>为页面添加动态效果</li> <li>无需刷新页面，即可以从服务器获取信息</li> <li>简化常见的JavaScript任务。</li></ul> <p>jQuery的优点：</p> <ol><li>利用CSS的选择器提供高速的元素查找行为。</li> <li>提供了一个抽象层来标准化各种常见的任务，可以解决各种浏览器的兼容问题。</li> <li>将复杂的代码简化，提供链式编程，大大简化了代码的操作。</li></ol> <h2 id="第四部分-vue"><a href="#第四部分-vue" class="header-anchor">#</a> 第四部分：vue</h2> <h3 id="_1-对vue生命周期的理解"><a href="#_1-对vue生命周期的理解" class="header-anchor">#</a> 1.对vue生命周期的理解?</h3> <p>Vue 实例从创建到销毁的过程，就是生命周期。vue的生命周期钩子，就是说达到某一个阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件。</p> <p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p> <p>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有</p> <p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p> <p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p> <p>销毁前/后：在执行$destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p> <h3 id="_2-created-和mounted时做了什么事情"><a href="#_2-created-和mounted时做了什么事情" class="header-anchor">#</a> 2.created 和mounted时做了什么事情</h3> <p>created：在实例创建完成后被立即调用，这个时候已经完成了data数据的观测。通常用来发请求获取数据。</p> <p>mounted：渲染模板挂载到vue实例对象上，通常用来操作dom元素</p> <p>beforeDestroy：通常用来移除监听事件及定时器函数。</p> <h3 id="_3-vue双向绑定原理"><a href="#_3-vue双向绑定原理" class="header-anchor">#</a> 3.vue双向绑定原理</h3> <p>当一个Vue实例创建时，Vue会遍历data选项的属性，用 <code>Object.defineProperty()</code> 将它们转为getter/setter 并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p> <p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 语法</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span>

<span class="token comment">// 参数</span>
obj：要定义属性的对象。
prop：要定义或修改的属性的名称或Symbol
descriptor：要定义或修改的属性描述符，是一个对象。

<span class="token comment">// 返回值</span>
被传递给函数的对象。
</code></pre></div><h3 id="_4-如果直接修改挂载在data数组里面的指定下标的值的话-视图会更新吗"><a href="#_4-如果直接修改挂载在data数组里面的指定下标的值的话-视图会更新吗" class="header-anchor">#</a> 4.如果直接修改挂载在data数组里面的指定下标的值的话 视图会更新吗</h3> <p>不会，原因是Vue2.+ 中data数据对象是通过Object.defineProerty来进行数据的双向数据绑定，而数组则是监听数组的push和pop等操作数组的方法进行双向绑定的，因此当是通过下标来修改时便不能更新视图</p> <h3 id="_5-vue中如何响应式的新增或修改数组-对象"><a href="#_5-vue中如何响应式的新增或修改数组-对象" class="header-anchor">#</a> 5.vue中如何响应式的新增或修改数组/对象？</h3> <p>通过<code>Vue实例.$set(target, key, value)</code></p> <p>参数：</p> <p>target：要更改的数据源（可以是对象或者数组）</p> <p>key：要更改的具体数据或者数组索引</p> <p>value：重新赋的值</p> <p>Vue.set()或者说 vm.$set()的原理：</p> <p>因为响应式数据我们给对象和数组本身新增了<code>__ob__</code>属性，代表的是Observer实例。当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪，然后会触发对象 <code>__ob__</code> 的dep收集到的watcher去更新，当修改数组索引时我们调用数组本身的splice方法去更新数组。</p> <h3 id="_6-vue中组件传值"><a href="#_6-vue中组件传值" class="header-anchor">#</a> 6.vue中组件传值：</h3> <p>父传子：在父组件中给子组件绑定自定义属性，在子组件中通过props接收</p> <p>子传父：在子组件中通过this.$emit(‘自定义函数名’, 数据)注册自定义事件，在父组件中给子组件绑定自定义事件并触发父组件中的函数，通过$event传递数据</p> <p>兄弟：使用全局通信总线，$emit()发布数据，$on()接收数据</p> <p>Vuex：定义全局数据state，通过this.$store.state获取数据，mutation修改state数据，action异步操作mutation，getters相当于组件中的计算属性，module模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。</p> <h3 id="_7-计算属性和侦听器的区别"><a href="#_7-计算属性和侦听器的区别" class="header-anchor">#</a> 7.计算属性和侦听器的区别</h3> <p>计算属性（computed）：计算属性是指当属性依赖的元素改变之后，当前属性也会随之改变。计算属性是有一个缓存的，即便你重新渲染组件，但是计算属性的值没有发生改变时，就不会去执行。</p> <p>侦听器（watch）：是指当侦听属性发生改变时，触发对应的侦听函数。如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择。</p> <h3 id="_8-vuex和本地存储的区别"><a href="#_8-vuex和本地存储的区别" class="header-anchor">#</a> 8.vuex和本地存储的区别</h3> <p>vuex存储在内存，localstorage（本地存储）则以文件的方式存储在本地,永久保存；sessionstorage( 会话存储 ) ，临时保存。</p> <p>localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</p> <p>vuex用于组件之间的传值，localstorage，sessionstorage则主要用于不同页面之间的传值。</p> <p>当刷新页面（这里的刷新页面指的是 --&gt; F5刷新,属于清除内存了）时vuex存储的值会丢失，sessionstorage页面关闭后就清除掉了，localstorage不会。</p> <h3 id="_9-vm-nexttick-callback-的用法"><a href="#_9-vm-nexttick-callback-的用法" class="header-anchor">#</a> 9.vm.$nextTick([callback])的用法</h3> <p>作用：在下一次DOM更新结束后执行其指定的回调。</p> <p>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</p> <p>异步队列更新dom导致的视图不更新，因为默认情况下，vuejs 是异步执行 dom 更新操作的。在下一个 tick 来临之前，vuejs 会收集数据变化，置于一个队列之中，下个 tick 来临之时，批量执行这些更新，并清空队列。虽然大部分情况下我们不需要关心这个更新 dom 机制，但是当下一步操作与之有关联时，我们就只能使用 this.$nextTick() 来解决了。即下一个数据的页面更新，依赖于上一个数据的页面更新完成时，才需要使用this.$nextTick()来解决</p> <h3 id="_10-vue-cli打包优化"><a href="#_10-vue-cli打包优化" class="header-anchor">#</a> 10.vue-cli打包优化</h3> <p>1.把VueCli升级到最新稳定版</p> <p>2.使用Gzip压缩</p> <p>3.不打包第三方包，使用CDN来加载资源存储</p> <p>4.路由懒加载 const 组件名 = () =&gt; import('@/views/setting/')</p> <p>5.按需加载第三方组件element-ui</p> <p>6.修改vue.config.js中的配置，把productionSourceMap改为false。不然在最终打包的文件中会出现一些map文件，map文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。</p> <h3 id="_11-使用vue实现点击一个按钮-第一次点击是红色-第二次点击是绿色-第三次点击是蓝色-第四次点击是黄色-第五次点击又重回红色-按照这个顺序写js"><a href="#_11-使用vue实现点击一个按钮-第一次点击是红色-第二次点击是绿色-第三次点击是蓝色-第四次点击是黄色-第五次点击又重回红色-按照这个顺序写js" class="header-anchor">#</a> 11.使用vue实现点击一个按钮，第一次点击是红色，第二次点击是绿色，第三次点击是蓝色，第四次点击是黄色，第五次点击又重回红色，按照这个顺序写js</h3> <p>定义一个数组存放颜色数据，声明一个数字表示数组索引，点击按钮，索引+1，显示索引对应的颜色，当索引大于4时重置索引值为0/</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">:style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{backgroundColor: colorArr[count]}<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>changeBGC<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点我改变背景颜色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'App'</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      <span class="token literal-property property">colorArr</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">changeBGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">&gt;=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><h3 id="_12-git版本管理"><a href="#_12-git版本管理" class="header-anchor">#</a> 12.git版本管理</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 初始化本地仓库</span>
<span class="token function">git</span> init

<span class="token comment"># 把文件添加到暂存区</span>
<span class="token function">git</span> <span class="token function">add</span> README.md

<span class="token comment"># 把暂存区文件提交到本地仓库形成历史记录</span>
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">&quot;first commit&quot;</span>

<span class="token comment"># 添加远端仓库地址到本地仓库</span>
<span class="token function">git</span> remote <span class="token function">add</span> origin https://github.com/lipengzhou/toutiao-publish-admin.git

<span class="token comment"># 推送到远程仓库</span>
<span class="token function">git</span> push <span class="token parameter variable">-u</span> origin master

<span class="token comment"># 查看文件状态</span>
<span class="token function">git</span> status

<span class="token comment"># 查看当前分支的版本历史</span>
<span class="token function">git</span> log

<span class="token comment"># 简略查看历史版本</span>
$ <span class="token function">git</span> log <span class="token parameter variable">--oneline</span>

<span class="token comment"># 恢复暂存区的指定文件到工作区</span>
$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span>

<span class="token comment"># 修改最近一次提交到暂存区的日志</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span>

输入i --<span class="token operator">&gt;</span> 进入编辑模式
Esc --<span class="token operator">&gt;</span> 退出编辑模式
:q --<span class="token operator">&gt;</span> 退出
:wq --<span class="token operator">&gt;</span> 保存并退出

<span class="token comment"># 创建一个分支，名字叫做dev</span>
$ <span class="token function">git</span> branch dev

<span class="token comment"># 切换分支命令；切换到dev分支上</span>
$ <span class="token function">git</span> checkout dev

<span class="token comment"># 合并某分支到当前分支</span>
$ <span class="token function">git</span> merge <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>

<span class="token comment"># 删除分支</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>
</code></pre></div><p>git之版本回退</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> log
<span class="token comment"># 定义：该命令显示从最近到最远的提交日志。每一次提交都有对应的commit id 和 commit message</span>

<span class="token comment"># 简略查看历史版本</span>
$ <span class="token function">git</span> log <span class="token parameter variable">--oneline</span>

<span class="token comment"># 根据id回退到指定的版本</span>
$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> <span class="token function">id</span>

<span class="token comment"># 回退到上一个版本，^表示回到上一个版本，如果需要回退到上上个版本的话，将HEAD^改成HEAD^^，以此类推。那如果要回退到前100个版本，可以使用简便命令操作：git reset --hard HEAD~100</span>
$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD^

<span class="token comment"># 查看所有操作的历史</span>
$ <span class="token function">git</span> reflog

<span class="token comment"># 推送本地到远程仓库，让远程仓库和本地一样，也进行了回滚</span>
$ <span class="token function">git</span> push origin HEAD <span class="token parameter variable">--force</span>
</code></pre></div><h3 id="_13-vue组件data为什么必须是一个函数"><a href="#_13-vue组件data为什么必须是一个函数" class="header-anchor">#</a> 13.Vue组件data为什么必须是一个函数？</h3> <p><code>new Vue()</code> 是一个单例模式，不会有任何的合并操作，所以根实例不必校验data一定是一个函数。组件的data必须是一个函数，是为了防止两个组件的数据产生污染。如果都是对象的话，会在合并的时候，指向同一个地址。而如果是函数的话，合并的时候调用，会产生两个空间。</p> <h3 id="_14-computed、watch、methods的区别"><a href="#_14-computed、watch、methods的区别" class="header-anchor">#</a> 14.computed、watch、methods的区别</h3> <p>计算属性computed：当你依赖data中的数据，通过逻辑处理得到新的数据，使用计算属性。</p> <ul><li>当你依赖的data中数据改变，计算属性的逻辑执行，计算属性改变。</li> <li>计算属性一定要return返回一个新数据。</li> <li>computed定义的函数是非响应式处理函数，页面一加载就会执行，且数据不发生改变的情况下仅执行一次，因为会缓存。</li> <li>使用场景：购物车结算</li></ul> <p>侦听器：当你想监听到某个数据变化，但不一定是依赖这个数据直接得到你想要的数。</p> <ul><li>你可能需要通过请求获取后台的数据，得到想要的数据，异步操作或者复杂逻辑操作（耗时较长）</li> <li>主要用来监听某个数据的变化，未必要得到新数据，即不一定有return</li> <li>使用场景：搜索框</li></ul> <p>computed能完成的功能，watch都可以完成。</p> <p>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p> <p>用computed和watch都能实现的需求，优先使用computed，computed更高效。</p> <p>methods定义函数，如果在模板中使用，每使用一次，就会调用一次函数，处理逻辑会重新执行。</p> <p>methods定义的函数是响应式处理函数，只有调用才会执行。</p> <h3 id="_15-v-for中key的作用-key的内部原理"><a href="#_15-v-for中key的作用-key的内部原理" class="header-anchor">#</a> 15.v-for中key的作用（key的内部原理）</h3> <ol><li><p>虚拟DOM中key的作用：</p> <p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p></li> <li><p>对比规则：</p> <p>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：</p> <ul><li>若虚拟DOM中内容没变，直接使用之前的真实DOM！</li> <li>若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</li></ul> <p>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key：</p> <ul><li>创建新的真实DOM，随后渲染到页面。</li></ul></li> <li><p>用index作为key可能会引发的问题：</p> <p>(1).若对数据进行：逆序添加、逆序删除等破坏顺序操作，会产生没有必要的真实DOM更新 ===&gt; 界面效果没问题，但效率低。</p> <p>(2).如果结构中还包含输入类的DOM：会产生错误的DOM更新 ===&gt; 界面有问题</p></li> <li><p>开发中如何选择key?</p> <p>(1).最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值</p> <p>(2).如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p></li></ol> <h3 id="_16-v-model的实现以及它的原理"><a href="#_16-v-model的实现以及它的原理" class="header-anchor">#</a> 16.v-model的实现以及它的原理？</h3> <p>Vue中双向绑定是一个指令<code>v-model</code>，可以绑定一个动态值到视图，同时视图中变化能改变该值。<code>v-model</code> 是语法糖，默认情况下相当于：value 和 @input。</p> <p>使用<code>v-model</code> 可以减少大量繁琐的处理代码，提高开发效率，代码可读性也更好。</p> <p>通常在表单项可以直接使用 <code>v-model</code> ，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件。</p> <h3 id="_17-sync-修饰符"><a href="#_17-sync-修饰符" class="header-anchor">#</a> 17.<code>.sync</code> 修饰符</h3> <p>在有些情况下，我们可能需要对一个prop进行“双向绑定”。但是，真正的双向绑定会调来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。</p> <p>假设要在父组件中给子组件绑定一个title属性，并且在子组件中某些情况下要修改title的值，可以这样写：</p> <p>子组件中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'update:title'</span><span class="token punctuation">,</span> newTitle<span class="token punctuation">)</span>
</code></pre></div><p>父组件中：</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token comment">&lt;!-- 给子组件绑定update事件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doc.title<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span><span class="token namespace">update:</span>title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doc.title = $event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Child</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><code>.sync</code> 修饰符就是一种语法糖写法</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name">:title.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doc.title<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Child</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="_18-keep-alive的实现"><a href="#_18-keep-alive的实现" class="header-anchor">#</a> 18.keep-alive的实现</h3> <p>作用：实现组件缓存。主要用于需要频繁切换的组件时进行缓存，不需要重新渲染页面。</p> <p>钩子函数：</p> <div class="language- extra-class"><pre class="language-text"><code>`activated` 组件渲染后调用
`deactivated` 组件销毁后调用
</code></pre></div><p>原理：<code>Vue.js</code> 内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>VNode</code>节点从<code>cache</code>对象中取出并渲染。</p> <p>配置属性：</p> <p><code>include</code>：字符串或正则表达式。只有名称匹配的组件会被缓存。</p> <p><code>exclude</code>：字符串或正则表达式。任何名称匹配的组件都不会被缓存。</p> <p><code>max</code>：数字。最多可以缓存多少组件实例。</p> <h3 id="_19-v-show和v-if指令的共同点和不同点"><a href="#_19-v-show和v-if指令的共同点和不同点" class="header-anchor">#</a> 19.v-show和v-if指令的共同点和不同点</h3> <p>相同点：都可以控制dom元素的显示和隐藏</p> <p>不同点：</p> <ul><li>v-show只是改变元素的display属性，dom元素并未消失，切换时不需要重新渲染页面；</li> <li>v-if是动态的向DOM树中添加或者删除DOM元素。直接将dom元素从页面删除，再次切换需要重新渲染页面</li></ul> <p>使用场景：</p> <ul><li>v-if适用于条件不大可能改变</li> <li>v-show适合频繁切换</li></ul> <h3 id="_20-如何获取dom"><a href="#_20-如何获取dom" class="header-anchor">#</a> 20.如何获取dom</h3> <p>给dom元素绑定ref属性，通过this.$refs.xxx进行获取dom元素。</p> <h3 id="_21-单页面应用和多页面应用的区别及缺点"><a href="#_21-单页面应用和多页面应用的区别及缺点" class="header-anchor">#</a> 21.单页面应用和多页面应用的区别及缺点</h3> <p>单页面应用（SPA），通俗的说就是指只有一个主页面的应用，浏览器一开始就加载所有的js、html、css。所有的页面内容都包含在这个主页面中。但在写的时候，还是分开写，然后在加载的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多用于PC端。</p> <p>多页面（MPA），就是一个应用中有多个页面，页面跳转时是整页刷新。</p> <p>单页面应用的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点SPA对服务器的压力较小；前后端分离，页面效果会比较炫酷。</p> <p>单页面应用的缺点：不利于SEO优化；导航不可用，如果一定要导航需要自行实现前进、后退。初次加载时耗时多；页面复杂度提高很多。</p> <h3 id="_22-父组件和子组件生命周期执行顺序是什么"><a href="#_22-父组件和子组件生命周期执行顺序是什么" class="header-anchor">#</a> 22.父组件和子组件生命周期执行顺序是什么？</h3> <ul><li><p>加载渲染过程：父beforeCreate ---&gt; 父Created ---&gt; 父beforeMount ---&gt; 子beforeCreate ---&gt; 子Created ---&gt; 子beforeMount ---&gt; 子mounted ---&gt; 父mounted</p></li> <li><p>子组件更新过程：父beforeUpdate ---&gt; 子beforeUpdate ---&gt; 子updated ---&gt; 父updated</p></li> <li><p>父组件更新过程：父beforeUpdate ---&gt; 父updated</p></li> <li><p>销毁过程：父beforeDestroy ---&gt; 子beforeDestroy ---&gt; 子destroyed ---&gt; 父destroyed</p></li></ul> <h3 id="_23-vue和jquery的区别"><a href="#_23-vue和jquery的区别" class="header-anchor">#</a> 23.Vue和jQuery的区别</h3> <p>jQuery是使用选择器（<code>$</code>）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：<code>$('label').val()</code>，它还是依赖DOM元素的值。</p> <p>Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，它们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</p> <h3 id="_24-v-for与v-if的优先级"><a href="#_24-v-for与v-if的优先级" class="header-anchor">#</a> 24.v-for与v-if的优先级</h3> <p>v-for和v-if同时使用，有一个先后运行的优先级，v-for比v-if优先级更高，这就说明在v-for每次渲染赋值中每一次调用v-if的判断，所以不推荐v-if和v-for在同一个标签中同时使用。</p> <h3 id="_25-虚拟dom是什么-有什么优缺点"><a href="#_25-虚拟dom是什么-有什么优缺点" class="header-anchor">#</a> 25.虚拟DOM是什么？有什么优缺点</h3> <p>由于在浏览器中操作DOM是很昂贵的。频繁操作DOM，会产生一定性能问题。这就是虚拟DOM的产生原因。虚拟DOM本质就是用一个原生的JS对象去描述一个DOM节点，是对真实DOM的一层抽象。</p> <p>优点：</p> <ol><li>保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，他的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限。</li> <li>无需手动操作DOM：我们不需要手动去操作DOM，只需要写好View-Model的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率。</li> <li>跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器渲染、weex开发等。</li></ol> <p>缺点：</p> <ol><li>无法进行极致优化：虽然虚拟DOM+合理的优化，足以应对大部分应用的性能需要，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。</li> <li>首次渲染大量DOM时，由于多了一层DOM计算，会比innerHTML插入慢。</li></ol> <p>Vue是如何把虚拟DOM转为真实DOM的？<a href="https://blog.csdn.net/qq_37947438/article/details/114481291" target="_blank" rel="noopener noreferrer">参考网页<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li>拿到template模板，通过compile编译成AST抽象语法树</li> <li>通过createElement方法把语法树转换为Vnode</li> <li>最后通过render方法把Vnode变为真实DOM</li></ol> <h3 id="_26-vue中使用了哪些设计模式"><a href="#_26-vue中使用了哪些设计模式" class="header-anchor">#</a> 26.Vue中使用了哪些设计模式？</h3> <ol><li><p>工厂模式 - 传入参数即可创建实例</p> <p>虚拟DOM根据参数的不同返回基础标签的Vnode和组件Vnode。</p></li> <li><p>单例模式 - 整个程序有且仅有一个实例</p> <p>Vuex和vue-router的插件注册方法install判断如果系统存在实例就直接返回掉。</p></li> <li><p>发布 - 订阅模式（Vue事件机制）</p></li> <li><p>观察者模式（响应式数据原理）</p></li> <li><p>装饰器模式（@装饰器的用法）</p></li> <li><p>策略模式，策略模式指对象有某个行为，但是在不同场景中，该行为有不同的实现方案 - 比如选项的合并策略。</p></li></ol> <h3 id="_27-你都做过哪些vue的性能优化"><a href="#_27-你都做过哪些vue的性能优化" class="header-anchor">#</a> 27.你都做过哪些Vue的性能优化</h3> <ul><li>对象层级不要过深，否则性能就会差</li> <li>不需要响应式的数据不要放在data中</li> <li>v-if和v-show区分使用场景</li> <li>computed和watch区分场景使用</li> <li>v-for遍历必须加key，key最好是id值，且避免同时使用v-if</li> <li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li> <li>防止内部泄露，组件销毁后把全局变量和事件销毁</li> <li>图片懒加载</li> <li>路由懒加载</li> <li>异步路由</li> <li>第三方插件的按需加载</li> <li>适当使用keep-alive缓存组件</li> <li>防抖、节流的运用</li> <li>服务端渲染SSR or 预渲染</li></ul> <p>###28.子组件为何不可以修改父组件传递的prop？</p> <p>所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级props的更新会向下流动到子组件中，但是反过来则不行。这样防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p> <h3 id="_29-vue中模板编译原理"><a href="#_29-vue中模板编译原理" class="header-anchor">#</a> 29.Vue中模板编译原理</h3> <p>模板指的就是template属性。vue内部会将template字符串转化成render函数进行渲染。render函数返回虚拟节点，再将虚拟节点转化成真实DOM。</p> <p>Vue编译原理这块的整体逻辑主要分为三个部分，也可以说是分三步，这三个部分是有前后关系的：</p> <ul><li>第一步是将模板字符串转换成element ASTs（解析器）</li> <li>第二步是对AST进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）</li> <li>第三步是使用element ASTs生成render函数代码字符串（代码生成器）</li></ul> <h3 id="_30-vue-data中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗"><a href="#_30-vue-data中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" class="header-anchor">#</a> 30.Vue data中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3> <p>不会立即同步执行重新渲染。**Vue实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新。**Vue在更新DOM时是异步执行的，只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p> <p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。然后，在下一个事件循环tick中，Vue刷新队列并执行实际（已去重）工作。</p> <p>###31.Vue-router共有几种模式？默认是哪种？</p> <p>有两种模式：hash模式和history模式，默认是hash模式。</p> <ul><li>hash：即地址栏URL中的#符号，它的特点在于：hash虽然出现在URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li> <li>history：利用了HTML5 History api 在浏览器中没有#，有浏览器兼容问题。history模式下，前端的URL必须和实际向后端发起请求的URL一致，如地址后加上/items/id，后端如果缺少对/items/id的路由处理，将返回404错误。</li></ul> <h3 id="_32-路由对象route和router的区别"><a href="#_32-路由对象route和router的区别" class="header-anchor">#</a> 32.路由对象route和router的区别</h3> <p>route路由信息对象，信息对象里面有参数和名字等信息。</p> <p>router路由实例，有一些方法，比如push()、replace()、go()、back()</p> <p>###33.路由跳转的方式</p> <ol><li><code>&lt;router-link to=&quot;需要跳转到页面的路径&quot;&gt;</code></li> <li><code>this.$router.push()</code> 跳转到指定的url，并在history中添加记录，点击回退返回到上一个页面</li> <li><code>this.$router.replace()</code> 跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面</li> <li><code>this.$router.go(n)</code> 向前或者向后跳转n个页面，n可以是正数也可以是负数</li></ol> <h3 id="_34-assets和static的区别"><a href="#_34-assets和static的区别" class="header-anchor">#</a> 34.assets和static的区别</h3> <p>assets中的文件会经过webpack打包，重新编译，推荐在assets存放js等需要打包编译的文件。static中的文件，不会打包编译。</p> <p>static中的文件只是复制一遍，static中建议放一些外部第三方文件，自己的放assets里。（图片推荐放在static里）</p> <h3 id="_35-vue2-0和vue3-0的区别"><a href="#_35-vue2-0和vue3-0的区别" class="header-anchor">#</a> 35.Vue2.0和Vue3.0的区别</h3> <p>最大的区别就是：Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）</p> <ol><li>双向数据绑定原理发生了改变，使用proxy替换Object.defineProperty，使用Proxy的优势：
<ul><li>可直接监听数组类型的数据变化</li> <li>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升</li> <li>可直接实现对象属性的新增/删除</li></ul></li> <li>默认使用懒加载。在2.x版本中。不管数据多大，都会在一开始就为其创建观察者，在数据很大时，就会造成性能的问题。在3.x中，只会对渲染出来的数据创建观察者，而且3.x的观察者更高效。</li> <li>3.0新加入了TypeScript以及PWA支持。</li> <li>生命周期有了一定的区别</li></ol> <table><thead><tr><th>Vue2</th> <th>Vue3</th> <th>说明</th></tr></thead> <tbody><tr><td>beforeCreate()</td> <td>setup()</td> <td>开始创建组件之前，创建的都是data和method</td></tr> <tr><td>created</td> <td>setup()</td> <td></td></tr> <tr><td>beforeMount()</td> <td>onBeforeMount()</td> <td>组件挂载到节点之前执行的函数</td></tr> <tr><td>mounted()</td> <td>onMounted()</td> <td>组件挂载完成后执行的函数</td></tr> <tr><td>beforeUpdate()</td> <td>onBeforeUpdate()</td> <td>组件更新之前执行的函数</td></tr> <tr><td>updated()</td> <td>onUpdated()</td> <td>组件更新完成之后执行的函数</td></tr> <tr><td>beforeDestroy()</td> <td>onBeforeUnmount()</td> <td>组件卸载之前执行的函数</td></tr> <tr><td>destroyed()</td> <td>onUnmounted()</td> <td>组件卸载之后执行的函数</td></tr> <tr><td>activated()</td> <td>onActivated()</td> <td>被缓存的组件激活时执行的函数</td></tr> <tr><td>deactivated()</td> <td>onDeactivated()</td> <td>被缓存的组件卸载后执行的函数</td></tr></tbody></table> <h3 id="_36-vue和react的区别"><a href="#_36-vue和react的区别" class="header-anchor">#</a> 36.Vue和React的区别</h3> <p>Vue：它是一个轻量级框架，其核心库只关注视图层，简单小巧、易学易上手；指令以v-xxx开头，个人维护项目；适合于移动端开发；不支持低版本浏览器；内置指令和自定义指令；内置过滤器和自定义过滤器；支持双向数据绑定；使用DOM模板。中心思想：一切都是组件，组件实例之间可以嵌套；核心库不内置Ajax，Route等功能，而是以插件的方式加载；基于依赖追踪的观察系统，并且异步队列更新。</p> <p>React：依赖虚拟DOM；采用特殊的JSX语法，中心思想：一切都是组件，组件实例之间可以嵌套；核心库不内置Ajax，Route等功能，而是以插件的方式加载。</p> <h3 id="_37-vue常用指令"><a href="#_37-vue常用指令" class="header-anchor">#</a> 37.Vue常用指令</h3> <p>v-text：更新标签的内容，格式是文本，和innerText相似，会覆盖标签内原来的内容。</p> <p>v-html：更新标签的内容，格式是html，和innerHTML相似，也会覆盖标签原来的内容。</p> <p>v-show：控制元素的显示和隐藏，使用的是display:none</p> <p>v-if：控制元素的显示和隐藏，实质是控制元素的创建和移除</p> <p>v-on:xxx：绑定事件，用@xxx符号简写。</p> <p>v-for：遍历标签（容器），需要依赖数据遍历。</p> <p>v-bind:xxx：动态绑定标签上的属性的值。用:xxx简写</p> <p>v-model：给表单元素添加双向数据绑定的功能。</p> <p>v-cloak：解决模板中的插值表达式的闪烁问题。这个指令在模板解析前生效，模板解析后会移除。</p> <p>v-once：让模板的某个容器只渲染一次，当它依赖的数据发生变化的时候，被指令修饰的容器不会再次渲染。</p> <h3 id="_38-组件化开发好处"><a href="#_38-组件化开发好处" class="header-anchor">#</a> 38.组件化开发好处</h3> <ul><li>高度复用</li> <li>组件与组件之间相互独立，例如：数据、函数。组件实现的功能足够单一，后期更好维护。</li></ul> <p>组件底层是什么？</p> <ul><li>组件本质上是一个vue实例，但是写法和Vue实例不同。</li> <li>组件会通过Vue.component()或者在Vue实例中new Vue({components: {}})</li> <li>组件也有配置对象，不包含el选项，el是指定Vue实例管理的视图容器，组件是通过template选项，指定html结构容器的。template的作用是模板占位符，可以帮助我们包裹元素。</li></ul> <h3 id="_39-vue-router导航守卫"><a href="#_39-vue-router导航守卫" class="header-anchor">#</a> 39.Vue-router导航守卫</h3> <p>导航守卫：在路由跳转前实现一些业务逻辑，可以控制跳转的最终目标。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 路由规则</span>
<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span><span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token literal-property property">redirect</span><span class="token operator">:</span> <span class="token string">'/home'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// redirect重定向</span>
    <span class="token punctuation">{</span><span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> Home<span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">// children是用来实现嵌套路由的配置选项</span>
        <span class="token punctuation">{</span><span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/tj'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> Tj<span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/top'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> Top<span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/login'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> Login<span class="token punctuation">}</span>
<span class="token punctuation">]</span>
<span class="token comment">// 初始化</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> routes <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 路由导航守卫</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

总结：
 作用：在路由跳转前执行里面的回调函数，实现一些业务，比如登录状态的判断和拦截。
 参数to：表示目标路由对象，to<span class="token punctuation">.</span>path表示目标路由对象的hash地址。
 参数form：表示来源路由对象。
 <span class="token function">参数next：下一步做的事情，如果不调用next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数，程序卡住，不再向下执行，类似中间件。
 <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">放行，跳转到目标地址；next</span><span class="token punctuation">(</span><span class="token string">'hash地址'</span><span class="token punctuation">)</span><span class="token function">表示跳转到指定的hash地址，比如next</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_40-vue监听路由变化"><a href="#_40-vue监听路由变化" class="header-anchor">#</a> 40.Vue监听路由变化</h3> <p>方法一：通过watch</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 监听，当路由发生变化的时候执行</span>
<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">$route</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>path<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 或者</span>
<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">$route</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 深度观察监听</span>
    <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token comment">// 或者</span>
<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">'$route'</span><span class="token operator">:</span> <span class="token string">'getPath'</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>path<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方法二：导航守卫</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在App.vue的created中全局监听路由</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>导航守卫分为：全局前置守卫（beforeEach(to, from, next)）、全局后置守卫（afterEach(to, from)）、路由独享的守卫（在路由规则routes中添加<code>beforeEnter: (to, from, next) =&gt; {}</code>）、组件内的守卫（在路由组件内直接定义<code>beforeRouteEnter(to, from, next){}</code>、<code>beforeRouteUpdate(to, from, next){}</code>、<code>beforeRouteLeave(to, from, next){}</code>）</p> <h2 id="第五部分-react"><a href="#第五部分-react" class="header-anchor">#</a> 第五部分：react</h2> <h3 id="_1-react组件传值"><a href="#_1-react组件传值" class="header-anchor">#</a> 1.React组件传值：</h3> <p>父传子：在父组件中给子组件绑定自定义属性，自定义属性值就是要传递的数据，在子组件中通过this.props.自定义属性获取</p> <p>子传父：在父组件上封装一个函数，将函数绑定给子组件，在子组件中通过this.props.自定义函数名()调用函数并传参，在父组件中即可接收参数。</p> <p>兄弟传值：在父祖件身上设置要共享的数据以及修改数据的函数，将数据和函数绑定给子组件的自定义属性</p> <p>祖孙传值context：在组件外调用React.createContext()创建Provider（提供数据）和Consumer（获取数据）两个组件；使用Provider组件包裹祖宗组件并设置value属性，传递数据；哪个孙子要接收数据，就用Consumer组件包裹，在里面使用箭头函数，箭头函数的参数就是传递过来的值，return一段html</p> <p>React-redux：全局数据状态管理容器，dispatch触发action，去找reducer，在reducer里面修改全局state数据</p> <h3 id="_2-虚拟dom和diff算法"><a href="#_2-虚拟dom和diff算法" class="header-anchor">#</a> 2.虚拟dom和diff算法</h3> <p>虚拟dom是一个Object对象模型，用来模拟真实dom节点的结构。</p> <p>虚拟dom的使用基本流程：</p> <ol><li><p>获取数据</p></li> <li><p>创建vdom</p></li> <li><p>通过render函数解析jsx，将其转化为vdom结构</p></li> <li><p>将vdom渲染成真实dom</p></li></ol> <p>Diff算法：比较两次虚拟dom，从上往下，一层一层的比较，如果当前组件没有变化，继续往下去比较；如果当前组件发现不同，react就不往下比较，里面即使一模一样，都不管直接更新当前组件及其所有后代。因为是虚拟dom，js对象在内存里面循环比较，所以即使全部删掉重来，速度也是很快的。</p> <h3 id="_3-react打包优化-重写webpack配置"><a href="#_3-react打包优化-重写webpack配置" class="header-anchor">#</a> 3.react打包优化，重写webpack配置</h3> <p>1.antd-mobile按需加载</p> <p>2.基于路由代码分割</p> <p>3.react-virtulized按需加载</p> <p>4.少使用图片，多使用字体图标</p> <h3 id="_4-react的特点"><a href="#_4-react的特点" class="header-anchor">#</a> 4.react的特点</h3> <ul><li>声明式：你只需要描述UI看起来是什么样式，就跟写HTML一样，React负责渲染UI</li> <li>基于组件：组件是React最重要的内容，组件表示页面中的部分内容</li> <li>学习一次，随处使用：使用react可以开发网页，react-native使用react语法，开发app。</li></ul> <h3 id="_5-react的使用"><a href="#_5-react的使用" class="header-anchor">#</a> 5.react的使用</h3> <ol><li><p>下载安装 <code>react</code>、<code>react-dom</code>包（<code>npm i react react-dom -s</code>）</p> <p>react包是核心，提供创建元素、组件等功能</p> <p>react-dom包提供DOM相关功能</p></li> <li><p>引入react和react-dom的两个js文件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./node_modules/react/umd/react.development.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./node_modules/react-dom/umd/react-dom.development.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>创建react元素</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建元素节点</span>
<span class="token comment">// 语法：React.createElement('标签名', {属性1: 值1, ...}, 标签内包裹的内容)</span>
<span class="token keyword">let</span> title <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'hello react'</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>渲染到页面</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 渲染到页面</span>
<span class="token comment">// 语法：ReactDOM.render(react元素, DOM元素)</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div></li></ol> <p>注意：</p> <ul><li>ReactDOM只会在index.js入口文件中使用一次</li> <li>React会在多个地方使用</li> <li>标签内容如果是引号包裹的内容，那么只会把它当作文本，即使里面有标签也不会识别，如果要使用标签，那么内容部分改为 <code>React.createElement('标签名', {属性1: 值1, ...}, 标签内包裹的内容)</code></li></ul> <h3 id="_6-react组件生命周期"><a href="#_6-react组件生命周期" class="header-anchor">#</a> 6.react组件生命周期</h3> <p>constructor()：初始化，仅执行一次。作用：1.初始化state  2.为事件处理程序绑定this</p> <p>render()：渲染到内存，执行多次。渲染UI，不能调用this.setState()修改state数据。</p> <p>componentDidMount()：初次渲染到页面，仅执行一次。作用：1.发送网络请求   2.执行DOM操作</p> <p>componentDidUpdate()：组件更新，执行多次。作用：1.发送网络请求   2.执行DOM操作 （如果要setState()必须放在一个if条件中）</p> <p>componentWillUnmount()：组件卸载，仅执行一次。作用：执行清理工作。</p> <p>shouldComponentUpdate()：控制组件是否更新</p> <p>页面一加载就执行：constructor() ---&gt;  render() ---&gt;  componentDidMount()</p> <p>页面更新：render() ---&gt;  componentDidUpdate()</p> <p>更新时机：setState()、forceUpdate()、组件接收到新的props，这三者任意一种变化，组件就会重新渲染。</p> <h2 id="第六部分-es6"><a href="#第六部分-es6" class="header-anchor">#</a> 第六部分：ES6</h2> <h3 id="_1-es6新特性"><a href="#_1-es6新特性" class="header-anchor">#</a> 1.es6新特性</h3> <p>声明变量的方式：let、const</p> <p>字符串：扩展的API</p> <ul><li><p>includes()：返回布尔值，表示是否找到了参数字符串。</p></li> <li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p></li> <li><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p> <p>这三个方法都支持第二个参数，表示开始搜索的位置。</p> <p>使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p></li> <li><p>repeat()：返回一个新字符串，表示将原字符串重复n次。</p> <p>注意：</p> <ul><li>参数如果是小数，会被取整。</li> <li>如果repeat的参数是负数或者Infinity，会报错。</li> <li>如果参数是0到-1之间的小数，则等同于0，这时因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。</li> <li>参数NaN等同于0。</li> <li>如果repeat的参数是字符串，则会先转换成数字。'na'==0,'3'==3</li></ul></li> <li><p>padStart()和padEnd()：如果某个字符串不够指定长度，会在头部或者尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p> <p>padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p> <p>注意：</p> <ul><li>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</li> <li>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截取超出位数的补全字符串。</li> <li>如果省略第二个参数，默认使用空格补全长度。</li></ul> <p>padStart()的常见用途是为数值补全指定位数。另一个用途是提示字符串格式。</p></li> <li><p>trimStart()和trimEnd()：消除字符串头部或者尾部的空格。返新字符串，不会修改原字符串。</p></li></ul> <p>数组：扩展的API</p> <ul><li><p>Array.from()：用于将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p> <p>类似数组的对象，本质特征只有一点，即必须有length属性。常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p> <p>只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。例如：字符串和Set结构。</p></li> <li><p>Array.of()：用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。Array()方法只有当参数不少于2个时，Array()才会返回由参数组成的新数组。参数只有一个正整数时，实际是指定数组的长度。</p></li> <li><p>copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。这个方法会修改当前数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">copyWithin</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
它接受三个参数：
 <span class="token operator">-</span> target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
 <span class="token operator">-</span> start（可选）：从该位置开始读取数据，默认为<span class="token number">0</span>。如果为负值，表示从末尾开始计算。
 <span class="token operator">-</span> end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。
<span class="token literal-property property">eg</span><span class="token operator">:</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">copyWithin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>find()：用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依此执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p></li> <li><p>findIndex()：与find()方法类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p> <p>这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。</p></li> <li><p>fill()：使用给定值，填充一个数组。fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p> <p>注意：如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p></li> <li><p>entries()、keys()、values()：用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p></li> <li><p>includes()：返回一个布尔值，表示某数组是否包含给定的值。该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它的绝对值大于数组长度，则会重置为从0开始。</p></li> <li><p>flat()：用于将嵌套的数组“拉平”，变成一维的数组（降维）。该方法返回一个新数组，对原数组没有影响。</p> <p>注意：</p> <ul><li>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。</li> <li>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</li> <li>如果原数组有空位，flat()方法会跳过空位。</li></ul></li> <li><p>flatMap()：对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。flatMap()只能展开一层。</p></li></ul> <p>Set()数据结构：不能重复的数据集合</p> <ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回Set结构本身。</li> <li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li> <li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li> <li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li> <li><code>Set.prototype.keys()</code>：返回键名的遍历器</li> <li><code>Set.prototype.values()</code>：返回键值的遍历器</li> <li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li> <li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul> <p>Map数据结构：JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。Map数据结构，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串---值”的对应，Map结构提供了“值---值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p> <p>模块化：import和export</p> <p>数组解构和对象解构、函数参数默认值、箭头函数、对象的属性简写、展开运算符...、</p> <p>Proxy代理：</p> <h3 id="_2-var-let-const的区别"><a href="#_2-var-let-const的区别" class="header-anchor">#</a> 2.var let const的区别</h3> <p>使用var声明的变量会挂载到window上，而使用let和const声明的变量则不会。</p> <p>使用var声明的变量存在声明提升的特性，而使用let和const声明的变量则不会。</p> <p>使用var声明的变量会超脱出块级作用域（for循环中的花括号或if中的花括号），而使用let和const声明的变量则不会。</p> <p>使用let声明的变量，不能再次定义，但是值可以改变。</p> <p>const声明的变量必须具备初始值且声明后不可修改，是最严格的语法，通常用于声明常量。</p> <h3 id="_3-箭头函数和普通函数的区别是什么"><a href="#_3-箭头函数和普通函数的区别是什么" class="header-anchor">#</a> 3.箭头函数和普通函数的区别是什么</h3> <ol><li>箭头函数是匿名函数，不能作为构造函数，不能使用new</li> <li>箭头函数不能绑定<code>arguments</code>，取而代之用<code>...</code> 接收剩余参数</li> <li>箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值</li> <li>箭头函数通过<code>call()</code> 或 <code>apply()</code> 方法调用一个函数时，只传入一个参数，对this并没有影响。</li> <li>箭头函数没有原型属性（没有prototype）</li> <li>箭头函数不能当作<code>Generator</code> 函数，不能使用 <code>yield</code> 关键字。</li></ol> <h3 id="_4-promise对象"><a href="#_4-promise对象" class="header-anchor">#</a> 4.Promise对象</h3> <p>Promise是一个异步函数，主要是为了解决异步处理回调地狱（也就是循环嵌套的问题）而产生的。</p> <p>Promise对象有以下两个特点：</p> <ol><li>对象的状态不受外界影响。Promise对象代表一个异步操作，有3种状态，pending（进行中），fulfilled（已成功），rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li> <li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为resolved（已定型）。</li></ol> <p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p> <p>基本用法：</p> <p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Promise构造函数接收一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由Javascript引擎提供，不用自己部署。</p> <p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p> <p>promise的then会返回一个新的promise对象，能保证then可以进行链式调用。</p> <h3 id="_5-es6的继承和es5的继承有什么区别"><a href="#_5-es6的继承和es5的继承有什么区别" class="header-anchor">#</a> 5.ES6的继承和ES5的继承有什么区别？</h3> <p>ES5的继承是通过原型或者构造函数机制来实现，ES6用class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承，子类必须在constructor方法中调用super方法。</p> <h3 id="_6-async、await的原理"><a href="#_6-async、await的原理" class="header-anchor">#</a> 6.async、await的原理</h3> <p>async和await是一种同步的写法，但还是异步的操作，两个必须配合一起使用。</p> <p>函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个promise对象。</p> <p>await是个运算符，用于组成表达式，await表达式的运算结果取决于它等的东西，如果是promise则会等待promise返回结果，接普通函数直接进行链式调用。</p> <p>await能够获取promise执行的结果，await必须和async一起使用才行，async配合await使用是一个阻塞的异步方法。如果await后面不是promise对象，就直接返回对应的值，只能在async函数中出现，普通函数直接使用会报错。await语句后的promise对象变成reject状态时，那么整个async函数会中断，后面的程序不会继续执行。</p> <h3 id="_7-for-in和for-of有什么区别"><a href="#_7-for-in和for-of有什么区别" class="header-anchor">#</a> 7.for...in和for...of有什么区别</h3> <ol><li>推荐在循环对象属性的时候，使用for...in，在遍历数组的时候使用for...of</li> <li>for...in遍历的是数组的索引，而for...of遍历的是数组元素值</li> <li>for...of不能循环普通的对象，需要通过和Object.keys()搭配使用</li> <li>for...in遍历顺序以数字为先，无法遍历symbol属性，可以遍历到公有中可枚举的</li> <li>从遍历对象的角度来说，for...in遍历出来的为对象的key，但for...of会直接报错。</li></ol> <p>###8.Promise顺序执行多个异步任务</p> <p>三个模拟的异步任务：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11111'</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'第一个异步进程'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'22222'</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'第二个异步进程'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">c</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'33333'</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'第三个异步进程'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方式一：arr.reduce()构建异步队列</p> <blockquote><p>Promise.resolve()：将现有对象转为Promise对象。Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。</p> <p>Array.prototype.reduce()：对数组中的每个元素按序执行一个由您提供的reducer函数，每一次运行reducer会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p> <p>语法：arr.reduce((previousValue, currentValue, currentIndex, array) =&gt; {}, initalValue)</p> <p>如果数组中的元素是Promise对象，reduce的作用就是构建异步队列。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promiseArr <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span>
promiseArr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cur<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span>resolve<span class="token punctuation">)</span>
</code></pre></div><p>本质上相当于：</p> <div class="language-js extra-class"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11111'</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'第一个异步进程'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 只有当第一个then返回了Promise对象才会接着调用下一个的then方法</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'22222'</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'第二个异步进程'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'33333'</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'第三个异步进程'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>方式二：arr.forEach()构建异步队列</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        res <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 相当于</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    a
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    b
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    c
<span class="token punctuation">)</span>
</code></pre></div><p>方式三：使用async，await实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">fun</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
</code></pre></div><h3 id="_9-promise同时执行多个异步任务"><a href="#_9-promise同时执行多个异步任务" class="header-anchor">#</a> 9.Promise同时执行多个异步任务</h3> <p>Promise.all()方法用于将多个Promise实例，包装成一个新的Promise实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>p的状态由p1、p2、p3决定，分成两种情况。</p> <ol><li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li> <li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3个接口返回'</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="第七部分-小程序"><a href="#第七部分-小程序" class="header-anchor">#</a> 第七部分：小程序</h2> <h3 id="_1-微信支付流程"><a href="#_1-微信支付流程" class="header-anchor">#</a> 1.微信支付流程？</h3> <p>客户端向服务器发请求提交申请支付，服务器向微信服务器申请获得支付暗号，服务器收到支付暗号后，将支付暗号响应给客户端，客户端拿到支付暗号后调用手机支付API，<code>wx.requestPayment(支付暗号)</code>发起支付。</p> <h3 id="_2-微信小程序如何实现支付宝支付"><a href="#_2-微信小程序如何实现支付宝支付" class="header-anchor">#</a> 2.微信小程序如何实现支付宝支付？</h3> <p>1.通过服务器端生成一个支付宝支付页面的URL网址；</p> <p>2.提示用户点击按钮复制该网址链接，然后打开第三方手机浏览器</p> <p>3.在手机浏览器的地址栏输入刚才复制的网址，然后打开，就可以直接完成支付宝支付了</p> <p>因为网址里面，包含了订单号信息，所以支付后，可以完成支付的回调通知。</p> <p>这种方式安全吗？</p> <p>安全性还是没问题的，因为网址中包含了订单号，也包含了一定时效的随机码，这个随机码保存在数据库中，超过一定的时间就无法完成支付，另外服务器端对用户访问入口进行了一些限制，所以安全性还是很有保障的。</p> <h3 id="_3-小程序适配rpx"><a href="#_3-小程序适配rpx" class="header-anchor">#</a> 3.小程序适配rpx</h3> <p>rpx可以根据屏幕宽度进行自适应。小程序规定，整个屏幕满宽的时候，在wxss中都是750rpx。rpx单位不是固定的，会变化的（rpx单位在不同手机上识别出不同的屏幕下代表的px值）。</p> <p>如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素</p> <h3 id="_4-小程序生命周期"><a href="#_4-小程序生命周期" class="header-anchor">#</a> 4.小程序生命周期</h3> <p>生命周期钩子函数：就是在特定的时间节点做一些特定事件。</p> <p>小程序中将生命周期分成两类：应用级别App；页面级别Page。</p> <p>App(Object object)</p> <p>注册小程序。接受一个objec参数，其指定小程序的生命周期回调等。</p> <p>App()必须在<code>app.js</code>中调用，必须调用且只能调用一次。不然会出现无法预期的后果。</p> <p>App生命周期函数说明:</p> <table><thead><tr><th>属性</th> <th>类型</th> <th>描述</th> <th>触发时机</th></tr></thead> <tbody><tr><td>onLaunch</td> <td>Function</td> <td>生命周期函数--监听小程序初始化</td> <td>当小程序初始化完成时，会触发onLaunch（全局只触发一次）</td></tr> <tr><td>onShow</td> <td>Function</td> <td>生命周期函数--监听小程序显示</td> <td>当小程序启动，或从后台进入前台显示，会触发onShow</td></tr> <tr><td>onHide</td> <td>Function</td> <td>生命周期函数--监听小程序隐藏</td> <td>当小程序从前台进入后台，会触发onHide</td></tr> <tr><td>其他</td> <td>Any</td> <td>开发者可以添加任意的函数或数据到Object参数中，用this可以访问</td> <td></td></tr></tbody></table> <p>前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p> <p>获取应用实例app对象:</p> <p>在全局js中通过App(appConfig)设置了app全局应用，在其他页面中可以通过getApp()方法获取此对象。</p> <p>全局数据最典型的应用场景就是保存或获取用户的信息。</p> <p>Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p> <table><thead><tr><th>属性</th> <th>类型</th> <th>描述</th> <th>触发时机</th></tr></thead> <tbody><tr><td>data</td> <td>Object</td> <td>页面的初始数据</td> <td></td></tr> <tr><td>onLoad</td> <td>Function</td> <td>生命周期函数--监听页面加载</td> <td>页面加载完成的时候执行，一个页面只会调用一次</td></tr> <tr><td>onReady</td> <td>Function</td> <td>生命周期函数--监听页面初次渲染完成</td> <td>页面初次渲染完成时执行，一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互</td></tr> <tr><td>onShow</td> <td>Function</td> <td>生命周期函数--监听页面显示</td> <td>每次打开页面都会执行</td></tr> <tr><td>onHide</td> <td>Function</td> <td>生命周期函数--监听页面隐藏</td> <td>每次页面切到后台或者切换到其他页面都会执行</td></tr> <tr><td>onUnload</td> <td>Function</td> <td>生命周期函数--监听页面卸载</td> <td>页面卸载的时候执行</td></tr> <tr><td>onPullDownRefreash</td> <td>Function</td> <td>页面相关事件处理函数--监听用户下拉动作</td> <td>页面下拉刷新时触发</td></tr> <tr><td>其他</td> <td>Any</td> <td>开发者可以添加任意的函数或数据到object参数中，用this可以访问</td> <td></td></tr></tbody></table> <p>事件处理函数</p> <p>除了初始化数据和生命周期函数，Page 中还可以定义一些特殊的函数：事件处理函数。在渲染层可以在组件中加入事件绑定，当达到触发事件时，就会执行 Page 中定义的事件。</p> <h3 id="_4-wxml语法"><a href="#_4-wxml语法" class="header-anchor">#</a> 4.WXML语法</h3> <h4 id="数据绑定"><a href="#数据绑定" class="header-anchor">#</a> 数据绑定</h4> <p>数据绑定：WXML中的动态数据均来自对应Page的data。</p> <p>数据绑定使用双大括号将变量包起来，可以作用于：内容、组件属性（需要在双引号之内）、控制属性（需要在双引号之内）、关键字（需要在双引号之内）。</p> <p>可以在 <code>{{}}</code> 内进行简单的运算，支持的有如下几种方式：三元运算、算术运算、逻辑判断、字符串运算、数据路径运算、组合构成新的对象或者数组。</p> <p>注意：</p> <ol><li>对象可以随意组合，但是如有变量名相同的情况，后边的会覆盖前面。</li> <li>花括号和引号之间如果有空格，将最终被解析成为字符串。</li></ol> <h4 id="列表渲染"><a href="#列表渲染" class="header-anchor">#</a> 列表渲染</h4> <p><code>wx:for</code></p> <p>在组件上使用 <code>wx:for</code> 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。</p> <p>默认数组的当前项的下标变量名默认为 <code>index</code> ，数组当前项的变量名默认为 <code>item</code></p> <p>使用 <code>wx:for-item</code> 可以指定数组当前元素的变量名，使用<code>wx:for-index</code> 可以指定数组当前下标的变量名。</p> <p><code>block wx:for</code> 类似 <code>block wx:if</code>，也可以将 <code>wx:for</code> 用在 <code>&lt;block /&gt;</code> 标签上，以渲染一个包含多节点的结构块。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>block</span> <span class="token attr-name"><span class="token namespace">wx:</span>for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{{[1, 2, 3]}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>{{index}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>block</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><code>wx:key</code></p> <p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如input中的输入内容，switch的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p> <p><code>wx:key</code> 的值以两种形式提供</p> <ol><li>字符串，代表在for循环中的array中item的某个property，该property的值需要是列表中唯一的字符串或数字，且不能动态改变。</li> <li>保留关键字 <code>*this</code> 代表在for循环中的item本身，这种表示item本身是一个唯一的字符串或者数字。</li></ol> <p>当数据改变触发渲染层重新渲染的时候，会校正带有key的组件，框架会确保他们被重新排序，而不是重新创建，以确保是组建保持自身的状态，并且提高列表渲染时的效率。</p> <p>如不提供 <code>wx:key</code> ，会报一个 <code>warning</code>，如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p> <p>注意：</p> <ul><li>当 <code>wx:for</code> 的值为字符串时，会将字符串解析成字符串数组</li> <li>花括号和引号之间如果有空格，将最终被解析成为字符串。</li></ul> <h4 id="条件渲染"><a href="#条件渲染" class="header-anchor">#</a> 条件渲染</h4> <p><code>wx:if</code></p> <p>在框架中，使用<code>wx:if=&quot;&quot;</code> 来判断是否需要渲染该代码块。也可以用<code>wx:elif</code> 和 <code>wx:else</code> 来添加一个else块。</p> <p><code>block wx:if</code></p> <p>因为 <code>wx:if</code> 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 <code>&lt;block /&gt;</code> 标签将多个组件包装起来，并在上边使用 <code>wx:if</code> 控制属性。</p> <p>注意：<code>&lt;block /&gt;</code> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p> <p><code>wx:if</code> VS <code>hidden</code></p> <p>因为 <code>wx:if</code> 之中的模板也可以包含数据绑定，所以当 <code>wx:if</code> 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。</p> <p>同时 <code>wx:if</code> 也是惰性的，如果在初识渲染条件为false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。</p> <p>相比之下，<code>hidden</code> 就简单的多，组件始终会被渲染，只是简单的控制显示和隐藏。</p> <p>一般来说，<code>wx:if</code> 有更高的切换消耗而 <code>hidden</code> 有更高的初始渲染消耗。因此，如果需要频繁切换的情况下，用 <code>hidden</code> 更好，如果在运行条件不大可能改变则 <code>wx:if</code> 较好。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 
   hidden的底层原理：display:none
   设置true表示隐藏，false表示显示
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">hidden</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{{key}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>我是块级元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h4 id="模板-template"><a href="#模板-template" class="header-anchor">#</a> 模板（template）</h4> <p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。</p> <p>定义模板：使用name属性，作为模板的名字。然后在 <code>&lt;template /&gt;</code> 内定义代码片段。</p> <p>使用 is 属性，声明需要使用的模板，然后将模板所需要的data传入。is 属性可以使用双大括号语法，来动态决定具体需要渲染哪个模板。</p> <p>模板作用域：模板拥有自己的作用域，只能使用data传入的数据以及模板定义文件中定义的 <code>&lt;wxs /&gt;</code> 模块。</p> <h4 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h4> <p>WXML提供了两种文件引入方式 <code>import</code> 和 <code>include</code>。</p> <p><code>import</code> 可以在该文件中使用目标文件定义的 <code>template</code>，例：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- item.wxml --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">&gt;</span></span>{{text}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 在index.wxml中引用item.wxml，就可以使用item模板 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>import</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.wxml<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span> <span class="token attr-name">data</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{{text: 'forbar'}}<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>import 的作用域</p> <p>import有作用域的概念，即只会import目标文件中定义的template，而不会import目标文件import的template。</p> <p>例：C中import B，B中import A，在C中可以使用B定义的 <code>template</code>，在 B中可以使用A定义的template，但是C不能使用A定义的 <code>template</code>。</p> <p><code>include</code> 可以将目标文件<strong>除了</strong> <code>&lt;template /&gt;</code> <code>&lt;wxs /&gt;</code> 外的整个代码引入，相当于是拷贝到 <code>include</code> 位置。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- index.wxml --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>header.wxml<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>body<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>footer.wxml<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token comment">&lt;!-- header.wxml --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span> header <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- footer.wxml --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span> footer <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="_5-wxs语法"><a href="#_5-wxs语法" class="header-anchor">#</a> 5.WXS语法</h3> <p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p> <p>WXS与JavaScript是不同的语言，有自己的语法，并不和JavaScript一致。</p> <h4 id="wxs模块"><a href="#wxs模块" class="header-anchor">#</a> WXS模块</h4> <p>WXS代码可以编写在wxml文件的 <code>&lt;wxs&gt;</code> 标签内，或以 <code>.wxs</code> 为后缀名的文件内。</p> <p><strong>模块</strong></p> <p>每一个 <code>.wxs</code> 文件和 <code>&lt;wxs&gt;</code> 标签都是一个单独的模块。</p> <p>每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。</p> <p>一个模块要想对外暴露其内部的私有变量与函数，只能通过 <code>module.exports</code> 实现。</p> <p><strong><code>.wxs</code> 文件</strong></p> <p>在微信开发者工具里面，右键可以直接创建 <code>.wxs</code> 文件，在其中直接编写 WXS 脚本。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /pages/comm.wxs</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">&quot;'hello world' from comm.wxs&quot;</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> d
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> foo<span class="token punctuation">,</span>
    <span class="token literal-property property">bar</span><span class="token operator">:</span> bar
<span class="token punctuation">}</span>
</code></pre></div><p>上述例子在 <code>/pages/comm.wxs</code> 的文件里面编写了WXS代码。该 <code>.wxs</code> 文件可以被其他的 <code>.wxs</code> 文件或WXML中的 <code>&lt;wxs&gt;</code> 标签引用。</p> <p><strong>module对象</strong></p> <p>每个 <code>wxs</code> 模块都有一个内置的 <code>module</code> 对象。</p> <p>属性：</p> <ul><li>exports：通过该属性，可以对外共享本模块的私有变量与函数。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /pages/tools.wxs</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">&quot;'hello world' from tools.wxs&quot;</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> d
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token constant">FOO</span><span class="token operator">:</span> foo<span class="token punctuation">,</span>
    <span class="token literal-property property">bar</span><span class="token operator">:</span> bar
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">'some msg'</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- page/index/index.wxml --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>wxs</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./../tools.wxs<span class="token punctuation">&quot;</span></span> <span class="token attr-name">module</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>tools<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>{{tools.msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>{{tools.bar(tools.FOO)}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>页面输出：</p> <div class="language- extra-class"><pre class="language-text"><code>some msg
'hello world' from tools.wxs
</code></pre></div><p><strong>require函数</strong></p> <p>在 <code>.wxs</code>模块中引用其他 <code>wxs</code> 文件模块，可以使用 <code>require</code> 函数。</p> <p>引用的时候，要注意如下几点：</p> <ul><li>只能引用 <code>.wxs</code> 文件模块，且必须使用相对路径。</li> <li><code>wxs</code>模块均为单例， <code>wxs</code>模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 <code>wxs</code>模块对象。</li> <li>如果一个 <code>wxs</code>模块在定义之后，一直没有被引用，则该模块不会被解析与运行。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /pages/tools.wxs</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">&quot;'hello world' from tools.wxs&quot;</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> d
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token constant">FOO</span><span class="token operator">:</span> foo<span class="token punctuation">,</span>
    <span class="token literal-property property">bar</span><span class="token operator">:</span> bar
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">&quot;some msg&quot;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /pages/logic.wxs</span>

<span class="token keyword">var</span> tools <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./tools.wxs&quot;</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tools<span class="token punctuation">.</span><span class="token constant">FOO</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tools<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token string">&quot;logic.wxs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tools<span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- /page/index/index.wxml --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>wxs</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./../logic.wxs<span class="token punctuation">&quot;</span></span> <span class="token attr-name">module</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>logic<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>控制台输出：</p> <div class="language- extra-class"><pre class="language-text"><code>'hello world' from tools.wxs
logic.wxs
some msg
</code></pre></div><p><strong><code>&lt;wxs&gt;</code> 标签</strong></p> <table><thead><tr><th>属性名</th> <th>类型</th> <th>默认值</th> <th>说明</th></tr></thead> <tbody><tr><td>module</td> <td>String</td> <td></td> <td>当前<code>&lt;wxs&gt;</code>标签的模块名。必填字段。</td></tr> <tr><td>src</td> <td>String</td> <td></td> <td>引用 <code>.wxs</code>文件的相对路径。仅当本标签为<strong>单闭合标签</strong>或<strong>标签的内容为空</strong>时有效。</td></tr></tbody></table> <p><strong>module 属性</strong></p> <p>module属性是当前 <code>&lt;wxs&gt;</code> 标签的模块名。在单个wxml文件内，建议其值唯一。有重复模块名则按照先后顺序覆盖（后者覆盖前者）。不同文件之间的wxs模块名不会相互覆盖。</p> <p>module 属性值的命名必须符合下面两个规则：</p> <ul><li>首字符必须是：字母（a-zA-Z），下划线（_）</li> <li>剩余字符可以是：字母（a-zA-Z），下划线（_），数字（0-9）</li></ul> <p>示例代码：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- wxml --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>wxs</span> <span class="token attr-name">module</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
var some_msg = &quot;hello world&quot;
module.exports = {
    msg: some_msg
}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>wxs</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>{{foo.msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>页面输出：</p> <div class="language- extra-class"><pre class="language-text"><code>hello world
</code></pre></div><p>上面例子声明了一个名字为 <code>foo</code> 的模块，将 <code>some_msg</code>变量暴露出来，供当前页面使用。</p> <p><strong>src 属性</strong></p> <p>src 属性可以用来引用其他是 <code>wxs</code> 文件模块。</p> <p>引用的时候，要注意如下几点：</p> <ul><li>只能引用 <code>.wxs</code> 文件模块，且必须使用相对路径。</li> <li><code>wxs</code> 模块均为单例， <code>wxs</code> 模块在第一次被引用时，会自动初识化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 <code>wxs</code> 模块对象。</li> <li>如果一个 <code>wxs</code> 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /pages/index/index.js</span>

<span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">&quot;'hello world' from js&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- /pages/index/index.wxml --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>wxs</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./../comm.wxs<span class="token punctuation">&quot;</span></span> <span class="token attr-name">module</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>some_comms<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>wxs</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 也可以直接使用单标签闭合的写法
&lt;wxs src=&quot;./../comm.wxs&quot; module=&quot;some_comms&quot; /&gt;
--&gt;</span>

<span class="token comment">&lt;!-- 调用 some_comms 模块里面的 bar 函数，且参数为 some_comms 模块里面的 foo --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>{{some_comms.bar(some_comms.foo)}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 调用 some_comms 模块里面的 bar 函数，且参数为 pages/index/index.js 里面的 msg --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">&gt;</span></span>{{some_comms.bar(msg)}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>页面输出：</p> <div class="language- extra-class"><pre class="language-text"><code>'hello world' from comm.wxs
'hello world' from js
</code></pre></div><p>上述例子在文件 <code>/pages/index/index.wxml</code> 中通过 <code>&lt;wxs&gt;</code> 标签引用了 <code>/page/comm.wxs</code> 模块。</p> <p><strong>注意事项</strong></p> <ul><li><code>&lt;wxs&gt;</code> 模块只能在定义模块的WXML文件中被访问到。使用 <code>&lt;include&gt;</code> 或 <code>&lt;import&gt;</code> 时，<code>&lt;wxs&gt;</code>模块不会被引入到对应的WXML文件中。</li> <li><code>&lt;template&gt;</code> 标签中，只能使用定义该 <code>&lt;template&gt;</code> 的WXML文件中定义的 <code>&lt;wxs&gt;</code> 模块。</li></ul> <h4 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h4> <p><strong>概念</strong></p> <ul><li>WXS中的变量均为值的引用。</li> <li>没有声明的变量直接赋值使用，会被定义为全局变量。</li> <li>如果只声明变量而不赋值，则默认值为 <code>undefined</code>。</li> <li>var 表现与JavaScript一致，会有变量提升。</li></ul> <p><strong>变量名</strong></p> <p>变量命名必须符合下面两个规则：</p> <ul><li>首字符必须是：字母（a-zA-Z）、下划线（_）</li> <li>剩余字符可以是：字母（a-zA-Z）、下划线（_）、数字（0-9）</li></ul> <h4 id="运算符"><a href="#运算符" class="header-anchor">#</a> 运算符</h4> <ul><li>基本运算符</li> <li>一元运算符</li> <li>位运算符</li> <li>比较运算符</li> <li>等值运算符</li> <li>赋值运算符</li> <li>二元逻辑运算符</li></ul> <h4 id="语句"><a href="#语句" class="header-anchor">#</a> 语句</h4> <ul><li>if 语句</li> <li>switch 语句</li> <li>for 语句</li> <li>while 语句</li></ul> <h4 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h4> <ul><li><code>number</code>：数值</li> <li><code>string</code>：字符串</li> <li><code>boolean</code>：布尔值</li> <li><code>object</code>：对象</li> <li><code>function</code>：函数</li> <li><code>array</code>：数组</li> <li><code>date</code>：日期</li> <li><code>regexp</code>：正则</li></ul> <p>数据类型判断</p> <ul><li>数据类型判断可以使用 <code>constructor</code> 属性。</li> <li>使用 <code>typeof</code> 可以区分部分数据类型。（可以区分简单数据类型和function，array、date、regexp都是object类型，undefined的typeof还是undefined，null的typeof是object）</li></ul> <h2 id="第七部分-优化"><a href="#第七部分-优化" class="header-anchor">#</a> 第七部分：优化</h2> <h3 id="_1-优化网站性能有哪些方法"><a href="#_1-优化网站性能有哪些方法" class="header-anchor">#</a> 1.优化网站性能有哪些方法？</h3> <p>减少http请求次数；资源合并和压缩；将外部脚本置底；懒加载；将css放到head中；避免重复的资源请求；代码优化；</p> <p>把CSS放头部，script放下方的原因：</p> <p>CSS放头部：在加载html生成DOM tree的时候，就可以同时对DOM tree进行渲染。这样可以防止闪跳，白屏或者布局混乱。</p> <p>JavaScript放在后面：JavaScript可能会改变DOM tree的结构，所以需要一个稳定的DOM tree。JavaScript加载后会立即执行，同时会阻塞后面的资源加载。（JavaScript加载和执行的特点）</p> <h3 id="_2-单页面应用的优化"><a href="#_2-单页面应用的优化" class="header-anchor">#</a> 2.单页面应用的优化？</h3> <p>图片压缩处理，页面滚动懒加载，路由懒加载，对于数据的预加载，css压缩抽离，js的分包，静态资源使用cdn存储，使用页面缓存减少频繁的网络请求，后端在部署代码要进行gzip压缩，首屏如果请求事件比较长为了更好的体验可以做一个比较友好的loading交互。</p> <h3 id="_3-单页面应用的优缺点"><a href="#_3-单页面应用的优缺点" class="header-anchor">#</a> 3.单页面应用的优缺点</h3> <p>单页面应用指只有一个主页面的应用，浏览器一开始就要加载所有必须的html，js，css，单页面的页面跳转仅刷新局部资源，多应用于pc端。</p> <p>单页面优点：1.用户体验好，快，内容改变不需要重新加载整个页面；2.没有页面之间的切换，就不会出现“白屏现象”</p> <p>单页面缺点：1.首次加载耗时比较多；2.不利于SEO；3.不可以用导航实现前进后退效果；4.页面复杂度高</p> <p>多页面就是指一个页面中有多个页面，页面跳转时是整页刷新。</p> <p>优点：首屏加载快</p> <p>缺点：跳转速度慢</p> <h3 id="_4-jsonp的实现原理"><a href="#_4-jsonp的实现原理" class="header-anchor">#</a> 4.JSONP的实现原理</h3> <p>同源指的是两个URL的协议、域名、端口一致，反之，则是跨域。</p> <p>出现跨域的根本原因：浏览器的同源策略不允许非同源的URL之间进行资源的交互。</p> <p>JSONP的实现原理，就是通过&lt;script&gt;标签的src属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据。</p> <p>传递数据是通过字符串拼接的方式，callback参数定义的方法是需要前后端定义好的，具体什么名字，商讨好就可以了。其实jsonp的整个过程就类似于前端声明好一个函数，后端返回执行函数。执行函数参数中携带所需的数据。</p> <h3 id="_5-解决跨域问题的方案"><a href="#_5-解决跨域问题的方案" class="header-anchor">#</a> 5.解决跨域问题的方案</h3> <p>跨域指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制，防止他人恶意攻击网站。</p> <p>1.JSONP解决跨域问题</p> <p>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</p> <p>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</p> <p>2.跨域资源共享CORS：在做出响应前，设置响应头，解决跨域问题'Access-Control-Allow-Origin': '*', // * 解决跨域，表示允许所有的网站来向我的接口发ajax请求</p> <p>CORS的优点：</p> <p>支持所有类型的请求；使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p> <p>CORS的缺点：</p> <p>一些老的浏览器不支持CORS</p> <p>3.<code>Websocket</code> 是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</p> <p>4.<code>Node</code>中间件代理</p> <p>5.<code>Nginx</code>反向代理</p> <h3 id="_6-浏览器兼容问题"><a href="#_6-浏览器兼容问题" class="header-anchor">#</a> 6.浏览器兼容问题</h3> <ul><li><p>解决ES6中的语法兼容，使用babel插件将ES6转ES5</p></li> <li><p>解决ES6中的API兼容，使用@babel/polyfil插件</p></li> <li><p>关于使用 event对象，出现的兼容性问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">如</span><span class="token operator">:</span> 获取鼠标位置
    <span class="token constant">IE</span><span class="token operator">/</span>Chrom<span class="token operator">:</span> event<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>event<span class="token punctuation">.</span>clientY
    <span class="token constant">FF</span><span class="token operator">/</span><span class="token constant">IE9</span>以上<span class="token operator">/</span>Chrom<span class="token operator">:</span> 传参ev<span class="token operator">--</span><span class="token operator">&gt;</span>ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>ev<span class="token punctuation">.</span>clientY
   <span class="token literal-property property">获取event对象兼容性写法</span><span class="token operator">:</span> <span class="token keyword">var</span> oEvent<span class="token operator">=</span> ev<span class="token operator">||</span>event<span class="token punctuation">;</span>
     document<span class="token punctuation">.</span><span class="token function-variable function">oncilck</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">var</span> oEvent<span class="token operator">==</span>ev<span class="token operator">||</span>event<span class="token punctuation">;</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>oEvent<span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token function">alert</span><span class="token punctuation">(</span>oEvent<span class="token punctuation">.</span>clientX<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
</code></pre></div></li> <li><p>关于获取滚动条距离而出现的问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">当我们获取滚动条滚动距离时</span><span class="token operator">:</span>
 <span class="token constant">IE</span><span class="token punctuation">,</span><span class="token literal-property property">Chrome</span><span class="token operator">:</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop
 <span class="token constant">FF</span><span class="token operator">:</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop
<span class="token literal-property property">兼容处理</span><span class="token operator">:</span>
<span class="token keyword">var</span> scrollTop<span class="token operator">=</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop<span class="token operator">||</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop
</code></pre></div></li> <li><p>关于使用 firstChild,lastChild 等，获取第一个/最后一个元素节点时产生的问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">--</span><span class="token constant">IE6</span><span class="token operator">-</span><span class="token number">8</span><span class="token literal-property property">下</span><span class="token operator">:</span> firstChild<span class="token punctuation">,</span>lastChild<span class="token punctuation">,</span>nextSibling<span class="token punctuation">,</span>previousSibling<span class="token punctuation">,</span><span class="token function">获取第一个元素节点</span>
 <span class="token punctuation">(</span>高版本浏览器<span class="token constant">IE9</span><span class="token operator">+</span><span class="token punctuation">,</span><span class="token constant">FF</span><span class="token punctuation">,</span>Chrome不兼容<span class="token punctuation">,</span>其获取的空白文本节点<span class="token punctuation">)</span>
<span class="token operator">--</span>高版本浏览器下<span class="token operator">:</span>        firstElementChild<span class="token punctuation">,</span>lastElementChild<span class="token punctuation">,</span>nextElementSibling<span class="token punctuation">,</span><span class="token function">previousElementSibling</span>
<span class="token punctuation">(</span>低版本浏览器<span class="token constant">IE6</span><span class="token operator">-</span><span class="token number">8</span>不兼容<span class="token punctuation">)</span>
<span class="token operator">--</span>兼容写法<span class="token operator">:</span> 找到ul的第一个元素节点<span class="token punctuation">,</span>并将其背景色变成红色
<span class="token keyword">var</span> oUl<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>oUl<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token comment">//高版本浏览器</span>
 oUl<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
 <span class="token comment">//IE6-8</span>
 oUl<span class="token punctuation">.</span>firstChild<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>不同浏览器的默认初始值不同。</p> <p>解决方法：引入全局控制样式，或者使用第三方</p></li> <li><p>块属性标签float后，又有横向的magin的情况下，在IE6显示margin比设置的大。</p> <p>解决方法：在float的标签样式控制中加入display:inline，将其转化为行内属性。</p></li> <li><p>标签最低高度设置min-height不兼容。</p> <p>解决方法：如果我们要设置一个标签的最小高度200px，需要进行的设置为：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token punctuation">{</span>
    <span class="token property">min-height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> auto <span class="token important">!important</span><span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">overflow</span><span class="token punctuation">:</span> visible<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_7-vue中对于所有的数据都有双向绑定的特性是吗"><a href="#_7-vue中对于所有的数据都有双向绑定的特性是吗" class="header-anchor">#</a> 7.vue中对于所有的数据都有双向绑定的特性是吗</h3> <h3 id="_8-浏览器的渲染流程"><a href="#_8-浏览器的渲染流程" class="header-anchor">#</a> 8.浏览器的渲染流程</h3> <p>参考文档：https://www.cnblogs.com/chenyoumei/p/9156849.html</p> <ol><li>根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS，阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完成，再继续构建DOM树及CSSOM树。</li> <li>构建渲染树（Render Tree）</li> <li>页面的重绘（repaint）于重排（reflow，也有称回流）。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是重排。</li></ol> <p><strong>加载JS</strong></p> <p>若在构建DOM树的过程中，当HTML解析器遇到一个script标记时，即遇到了JS，将立即阻塞DOM树的构建，将控制权移交给JavaScript引擎，等到JavaScript引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建。</p> <p>其根本原因在于，**JS会对DOM节点进行操作，浏览器无法预测未来的DOM节点的具体内容，为了防止无效操作，节省资源，只能阻塞DOM树的构建。**譬如，若不阻塞DOM树的构建，若JS删除了某个DOM节点A，那么浏览器为构建此节点A花费的资源就是无效的。或者JS企图访问script标签后面的DOM元素，浏览器就会抛出找不到该DOM元素的错误。</p> <p>若在HTML头部加载JS文件，由于JS阻塞，会推迟页面的首绘。为了加快页面渲染，一般将JS文件放在HTML底部进行加载，或是对JS文件执行async或defer加载。</p> <p><strong>构建渲染树</strong></p> <p>渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。</p> <p>构建渲染树，根据渲染树计算每个可见元素的布局，并输出到绘制流程，将像素渲染到屏幕上。</p> <p>重排：若渲染树的一部分更新，且尺寸变化，就会发生重排；</p> <p>重绘：部分节点需要更新，但不改变其他集合形状。如改变某个元素的颜色，就会发生重绘。</p> <h3 id="_9-webpack"><a href="#_9-webpack" class="header-anchor">#</a> 9.webpack</h3> <p>webpack是一个模块打包器，它本身主要打包JavaScript模块以及其他的一些浏览器不能直接运行的拓展语言（Scss、TypeScript等），并将其转换和打包为合适的格式供浏览器使用。主要用于模块化方案，预编译模块的方案。</p> <p>可以压缩代码和图片，配置跨域、路径别名、打包分析、cdn映入、去掉console.log、单独打包第三方模块、ie兼容、eslint规范。</p> <h3 id="_10-webpack的loader和plugins的区别"><a href="#_10-webpack的loader和plugins的区别" class="header-anchor">#</a> 10.webpack的loader和plugins的区别？</h3> <p>loader用于加载待打包的资源，plugin用于扩展webpack。</p> <p>loader用于加载某些资源文件。因为webpack本身只能打包commonjs规范的js文件，对于其他资源，例如css、图片，或者其他的语法集，比如jsx，是没有办法加载的。这就需要对应的loader将资源转化，加载进来。从字面意思也能看出，loader是用于加载的，它作用于一个个文件上。</p> <p>plugin用于扩展webpack的功能。他直接作用于webpack，扩展了它的功能。当然loader也变相的扩展了webpack，但是它只专注于转化文件这一个领域。而plugin的功能更加的丰富，而不仅局限于资源的加载。</p> <h3 id="_11-node是什么"><a href="#_11-node是什么" class="header-anchor">#</a> 11.Node是什么？</h3> <p>Node是一个基于Chrome V8引擎的JavaScript代码运行环境。</p> <p>浏览器是JavaScript代码的前端运行环境，Node是JavaScript代码的后端运行环境，内部提供了基础的功能和API。</p> <p>Node的优点：简单强大，轻量可扩展。</p> <p>简单体现在node使用的是JavaScript、json来进行编码；强大体现在非阻塞IO，可以适应分块传输数据，较慢的网络环境，尤其擅长高并发访问；轻量体现在node本身既是代码，又是服务器，前后端使用统一语言；可扩展体现在可以轻松应对多实例，多服务器架构，同时有海量的第三方应用组件。</p> <h3 id="_12-模块化的意义"><a href="#_12-模块化的意义" class="header-anchor">#</a> 12.模块化的意义</h3> <p>降低软件的复杂性，使其可控、可维护、可扩展。</p> <p>一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模板不会影响其他功能的运行。</p> <h2 id="第八部分-计算机基础"><a href="#第八部分-计算机基础" class="header-anchor">#</a> 第八部分：计算机基础</h2> <h3 id="_1-http和https的区别"><a href="#_1-http和https的区别" class="header-anchor">#</a> 1.http和https的区别</h3> <p>1.https协议需要到CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。</p> <p>2.http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p> <p>3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p> <p>4.http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p> <h3 id="_2-http请求消息的组成部分"><a href="#_2-http请求消息的组成部分" class="header-anchor">#</a> 2.http请求消息的组成部分</h3> <p>HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。</p> <p>请求行由请求方式、URL 和 HTTP 协议版本 3 个部分组成，他们之间使用空格隔开。</p> <p>请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。比如：User-Agent 用来说明当前是什么类型的浏览器；Content-Type 用来描述发送到服务器的数据格式；Accept 用来描述客户端能够接收什么类型的返回内容；Accept-Language 用来描述客户端期望接收哪种人类语言的文本内容。</p> <p>请求头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。</p> <p>最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。</p> <p>请求消息中的空行，用来分隔请求头部与请求体。</p> <p>请求体中存放的，是要通过 POST 方式提交到服务器的数据。</p> <p>注意：只有 POST 请求才有请求体，GET 请求没有请求体！</p> <h3 id="_3-http响应消息的组成部分"><a href="#_3-http响应消息的组成部分" class="header-anchor">#</a> 3.http响应消息的组成部分</h3> <p>HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成。</p> <p>状态行由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;</p> <p>响应头部用来描述服务器的基本信息。响应头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。</p> <p>Access-Control-Allow-Origin：访问控制允许来源，http请求头信息，设定允许资源共享（跨域）的源。* 表示允许所有的源。</p> <p>在最后一个响应头部字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束。</p> <p>响应消息中的空行，用来分隔响应头部与响应体。</p> <p>响应体中存放的，是服务器响应给客户端的资源内容。</p> <h3 id="_4-响应状态码"><a href="#_4-响应状态码" class="header-anchor">#</a> 4.响应状态码</h3> <p>2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：</p> <table><thead><tr><th>状态码</th> <th>状态码英文名称</th> <th>中文描述</th></tr></thead> <tbody><tr><td><strong>200</strong></td> <td>OK</td> <td>请求成功。一般用于 GET 与 POST 请求</td></tr> <tr><td>201</td> <td>Created</td> <td>已创建。成功请求并创建了新的资源，通常用于 POST 或 PUT 请求</td></tr></tbody></table> <p>3** 范围的状态码，表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：</p> <table><thead><tr><th><strong>状态码</strong></th> <th><strong>状态码英文名称</strong></th> <th><strong>中文描述</strong></th></tr></thead> <tbody><tr><td>301</td> <td>Moved Permanently</td> <td>永久重定向。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr> <tr><td><strong>302</strong></td> <td>Found</td> <td>临时重定向。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr> <tr><td><strong>304</strong></td> <td>Not Modified</td> <td>资源缓存。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td></tr></tbody></table> <p>4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下：</p> <table><thead><tr><th><strong>状态码</strong></th> <th><strong>状态码英文名称</strong></th> <th><strong>中文描述</strong></th></tr></thead> <tbody><tr><td>400</td> <td>Bad Request</td> <td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。</td></tr> <tr><td>401</td> <td>Unauthorized</td> <td>当前请求需要用户验证。</td></tr> <tr><td>403</td> <td>Forbidden</td> <td>服务器已经理解请求，但是拒绝执行它。</td></tr> <tr><td><strong>404</strong></td> <td>Not Found</td> <td>服务器无法根据客户端的请求找到资源（网页）。</td></tr> <tr><td>408</td> <td>Request Timeout</td> <td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td></tr></tbody></table> <p>5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的 5** 类型的状态码如下：</p> <table><thead><tr><th><strong>状态码</strong></th> <th><strong>状态码英文名称</strong></th> <th><strong>中文描述</strong></th></tr></thead> <tbody><tr><td><strong>500</strong></td> <td>Internal Server Error</td> <td>服务器内部错误，无法完成请求。</td></tr> <tr><td>501</td> <td>Not Implemented</td> <td>服务器不支持该请求方法，无法完成请求。只有 GET 和 HEAD 请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501</td></tr> <tr><td><strong>503</strong></td> <td>Service Unavailable</td> <td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr></tbody></table> <h3 id="_5-tcp连接的三次握手-四次挥手"><a href="#_5-tcp连接的三次握手-四次挥手" class="header-anchor">#</a> 5.TCP连接的三次握手，四次挥手</h3> <p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p> <p>建立连接三次握手：</p> <p><img src="/assets/img/established.614ad78a.png" alt=""></p> <ul><li><strong>第一次握手</strong>：
客户端将TCP报文<strong>标志位SYN置为1</strong>，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</li> <li><strong>第二次握手</strong>：
服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文<strong>标志位SYN和ACK都置为1</strong>，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入<code>SYN_RCVD</code>状态。</li> <li><strong>第三次握手</strong>：
客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li></ul> <p>注意:我们上面写的ack和ACK，不是同一个概念：</p> <ul><li>小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。</li> <li>大写的ACK，则是TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。</li></ul> <p>释放连接四次握手：</p> <p><img src="/assets/img/close.9a869524.png" alt=""></p> <p>对于一个已经建立的连接，TCP使用改进的四次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：</p> <p>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p> <p>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ack，同时通知自己相应的应用程序：对方要求关闭连接（先发送ack的目的是为了防止在这段时间内，对方重传FIN报文段）。</p> <p>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A发送一个FIN报文段。</p> <p>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p> <h3 id="_6-get和post方式的区别"><a href="#_6-get和post方式的区别" class="header-anchor">#</a> 6.GET和POST方式的区别</h3> <p>1.字面意思不同</p> <p>GET获取，想从服务器中获取数据，用GET方式</p> <p>POST是邮递，邮寄的意思，如果提交数据到服务器，用POST方式</p> <p>2.请求参数位置不同</p> <p>GET请求参数会和url拼接到一起，形如：api/getbooks?id=2</p> <p>POST提交的数据放在Request body中</p> <p>3.携带的数据量大小不一样</p> <p>GET方式能够携带少量的数据，一般浏览器允许的url的长度是2k</p> <p>POST方式能够携带的数据量大小没有限制</p> <p>4.上传文件</p> <p>上传文件只能够使用POST方式</p> <p>5.本质区别</p> <p>GET方式不会对服务器的数据做出改变</p> <p>POST方式非常可能对服务器的数据做出改变</p> <p>浏览器工具中，GET和POST方式的区别：</p> <p>Hearders中的Query String Parameters中查看每次请求携带的参数</p> <h3 id="_7-描述一下http的请求过程与原理"><a href="#_7-描述一下http的请求过程与原理" class="header-anchor">#</a> 7.描述一下HTTP的请求过程与原理？</h3> <p>HTTP请求的过程：</p> <p>域名解析 ---&gt;  发起TCP的3次握手 ---&gt; 建立TCP连接后发起http请求 ---&gt; 服务器响应http请求，浏览器得到html代码 ---&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） ---&gt; 浏览器对页面进行渲染呈现给用户</p> <p>请求原理：</p> <p>HTTP协议是应用层的一种协议，是一种C/S架构服务，基于TCP/IP协议来通信，监听在TCP的80端口上，HTTP协议实现的是客户端可以向服务端获得web资源。</p> <h3 id="_8-tcp和udp的区别"><a href="#_8-tcp和udp的区别" class="header-anchor">#</a> 8.TCP和UDP的区别</h3> <p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p> <p>UDP（用户数据报协议）是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p> <p>TCP是面向连接的传输控制协议，而UDP提供了无连接的数据报服务，类似电话与短信。</p> <p>TCP首部开销20字节，UDP首部开销8字节。</p> <p>TCP逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</p> <p>UDP没有拥塞机制，因此网络出现拥堵不会使源主机的发送效率降低（有利于实时会议视频等）</p> <p>TCP的连接只能是点到点的，UDP支持一对一，多对一，多对多的交互通信。</p> <h3 id="_9-介绍一下websocket"><a href="#_9-介绍一下websocket" class="header-anchor">#</a> 9.介绍一下websocket?</h3> <p>websocket是一种网络通信协议，是HTML5开始提供的一种在单个TCP连接上进行全双工通信的协议，这个对比着http协议来说，http协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。http协议无法实现服务器主动向客户端发起消息，websocket连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。websocket只需建立一次连接，就可以一直保持连接状态。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 初始化一个WebSocket对象</span>
<span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:9998/echo'</span><span class="token punctuation">)</span>
<span class="token comment">// 建立WebSocket连接成功触发事件</span>
ws<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用send()方法发送数据</span>
    ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'发送数据'</span><span class="token punctuation">)</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'数据发送中...'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 接收服务端数据时触发事件</span>
ws<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    varr received_msg <span class="token operator">=</span> evt<span class="token punctuation">.</span>data
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'数据已接收...'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 断开WebSocket连接成功触发事件</span>
ws<span class="token punctuation">.</span><span class="token function-variable function">onclose</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'连接已关闭'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_10-浏览器中输入url到网页显示-整个过程发生了什么"><a href="#_10-浏览器中输入url到网页显示-整个过程发生了什么" class="header-anchor">#</a> 10.浏览器中输入url到网页显示，整个过程发生了什么？</h3> <ol><li>域名解析</li> <li>发起tcp三次握手</li> <li>建立tcp连接之后发起http请求</li> <li>服务器端响应http请求，浏览器得到html代码</li> <li>浏览器解析html代码，并请求html代码中的资源</li> <li>浏览器对页面进行渲染呈现给用户</li></ol> <h3 id="_7-谈谈你对web标准以及w3c的理解与认识问题"><a href="#_7-谈谈你对web标准以及w3c的理解与认识问题" class="header-anchor">#</a> 7.谈谈你对WEB标准以及W3C的理解与认识问题</h3> <p>web标准简单来说可以分为结构、表现和行为。其中结构主要是有HTML标签组成。或许通俗点说，在页面body里面我们写入的标签都是为了页面的结构。表现即指css样式表，通过css可以使页面的结构标签更具美感。行为是指页面和用户具有一定的交互，控制页面结构或者表现发生变化，主要是有js组成。</p> <p>web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。</p> <p>W3C对web标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点</p> <p>1.对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对SEO很有帮助）</p> <p>1）标签字母要小写</p> <p>2）标签要闭合</p> <p>3）标签不允许随意嵌套</p> <p>2.对于css和js来说</p> <p>1）尽量使用外链css样式表和js脚本。使结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。</p> <p>2）样式尽量少用行间样式表，使结构与表现分离，标签的id和class等属性命名要做到见名知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版。</p> <p>3）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</p> <h3 id="_8-前端技术栈"><a href="#_8-前端技术栈" class="header-anchor">#</a> 8.前端技术栈</h3> <p>浏览器：IE6~IE8 IE9+ chrome Firefox Safari Opera Edge</p> <p>HTTP协议：URL Cache Session Cookie Request Response</p> <p>HTML: W3C HTML4.0 HTML5 DOM 语义化</p> <p>CSS: CSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎</p> <p>JavaScript: EcmaScript356 Lexical-scope prototype-chain AJAX js引擎</p> <p>编辑器: Emacs Vim Webstorm Atom Sublime-Text</p> <p>发布部署: 合并 压缩 单元测试 Nodejs Grunt Gulp Yeoman Phantom JSLint</p> <p>框架类型：jQuery Zepto UnderScore Backbone Knockout React AngularJS</p> <p>模块管理：commonJS Webpack</p> <p>UI框架：BootStrap SemanticUI jQueryUI Foundation</p> <p>推送技术：WebSocket 轮询 长连接</p> <p>跨域技术：iframe JSONP CORS</p> <p>数据可视化：D3 Echarts Highcharts Canvas</p> <p>异步编程：Promise $.Deferred Generator</p> <p>CSS预处理器：LESS SASS Stylus</p> <p>客户端模板：Handlebars Haml Jade Mustache</p> <p>相关语言：CoffeeScript TypeScript Dart WebAssembly</p> <p>WedApp/PC React-native ionic</p> <p>C/Rust/Go</p> <p>C#/Java</p> <p>Scheme/Haskell</p> <p>PHP/Python/Ruby</p> <p>Prolog/Erlang</p> <p>包含命令式，面向对象，函数式，逻辑式</p> <p>##第九部分：面试手写代码</p> <h3 id="_1-防抖"><a href="#_1-防抖" class="header-anchor">#</a> 1.防抖</h3> <p>防抖策略（debounce）是当事件被触发后，延迟n秒后再执行回调函数，如果在这n秒内事件又被触发，则重新计时。</p> <p>防抖的应用场景：</p> <p>用户在输入框连续输入一串字符时，可以通过防抖策略，只在输入完成后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源。</p> <p><img src="/assets/img/anti-shake.6377d959.png" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 需求：窗口大小Resize。只需要窗口调整完成后，计算窗口大小，防止重复渲染。</span>
<span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> betterFn <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn 防抖执行了'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scoll'</span><span class="token punctuation">,</span> betterFn<span class="token punctuation">)</span>
</code></pre></div><h3 id="_2-节流"><a href="#_2-节流" class="header-anchor">#</a> 2.节流</h3> <p>节流策略（throttle），顾名思义，可以减少一段时间内事件的触发频率。</p> <p>节流的应用场景：</p> <ol><li>鼠标连续不断地触发某事件（如点击），在单位时间内只触发一次；</li> <li>懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费CPU资源。</li></ol> <p><img src="/assets/img/throttle.480df050.png" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> pre <span class="token operator">&gt;=</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
            pre <span class="token operator">=</span> now
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>防抖和节流的区别：</p> <p>防抖：如果事件被频繁触发，防抖能保证只有最后一次触发生效！前面N多次的触发都会被忽略！</p> <p>节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！</p> <h3 id="_3-对象深浅拷贝"><a href="#_3-对象深浅拷贝" class="header-anchor">#</a> 3.对象深浅拷贝</h3> <p>浅拷贝</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> source<span class="token punctuation">)</span>
<span class="token number">2.</span><span class="token function">es6对象扩展运算符</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
</code></pre></div><p>深拷贝</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token number">2.</span>递归操作
<span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">let</span> newObj <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newObj
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_4-数组去重、数组对象去重"><a href="#_4-数组去重、数组对象去重" class="header-anchor">#</a> 4.数组去重、数组对象去重</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 数组</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token comment">// 第一种：排序后比较法</span>
<span class="token keyword">const</span> arrNew <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// a.排序</span>
arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// b.遍历这个排序后的数组，始终把当前项和它后面的这一项进行比较，如果相等就说明重复了，就不添加当前项，如果不等，就添加</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">!=</span> arr<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arrNew<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span> <span class="token comment">// [2, 7, 5, 8, 9]</span>

<span class="token comment">// 第二种：利用对象法</span>
<span class="token comment">// 原理：对象是能有重复的属性的</span>
<span class="token comment">// 如果对象有这个属性，就取这个对象的属性，如果没有这个属性，就给对象添加</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> arrNew <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// 遍历arr</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arrNew<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
        obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span> <span class="token comment">// [2, 7, 5, 8, 9]</span>

<span class="token comment">// 第三种：ES6中的Set</span>
<span class="token comment">// Set是一中数据类型和数组差不多，但是区别是Set不能放重复的项</span>
<span class="token keyword">var</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
<span class="token comment">// ...展开运算符不仅可以展开数组，还可以展开对象</span>
<span class="token keyword">var</span> arrNew <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>set<span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span> <span class="token comment">// [2, 7, 5, 8, 9]</span>

<span class="token comment">// 数组对象</span>
<span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'李四'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'王五'</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> hash <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    hash<span class="token punctuation">[</span>next<span class="token punctuation">.</span>age<span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token string">''</span> <span class="token operator">:</span> hash<span class="token punctuation">[</span>next<span class="token punctuation">.</span>age<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> item<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span>
    <span class="token keyword">return</span> item
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>
</code></pre></div><h3 id="_5-数组扁平化"><a href="#_5-数组扁平化" class="header-anchor">#</a> 5.数组扁平化</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第一种：使用数组的concat()方法</span>
<span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法用于合并两个或多数组。此方法不会更改现有数组，而是返回一个新数组。
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arrNew <span class="token operator">=</span> arr2<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span> <span class="token comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'h', 'i', [j]]</span>

<span class="token comment">// 第二种：使用ES6中的展开运算符</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> arrNew <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arrNew<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span> <span class="token comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'h', 'i', [j]]</span>

<span class="token comment">// 多层嵌套数组</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">flatten</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> item<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_6-数组升维"><a href="#_6-数组升维" class="header-anchor">#</a> 6.数组升维</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/* 数组升维：把一维数组变成二维数组 */</span>

<span class="token comment">//需求 ： 将下列数组arr，根据类别type升为二维数组</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'电子产品'</span><span class="token punctuation">,</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'iPhone'</span><span class="token punctuation">,</span>  <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">8888</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'家具'</span><span class="token punctuation">,</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'桌子'</span><span class="token punctuation">,</span>    <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'食品'</span><span class="token punctuation">,</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'瓜子'</span><span class="token punctuation">,</span>    <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'家具'</span><span class="token punctuation">,</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'椅子'</span><span class="token punctuation">,</span>    <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">380</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'电子产品'</span><span class="token punctuation">,</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'小米手机'</span><span class="token punctuation">,</span><span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">1380</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'食品'</span><span class="token punctuation">,</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'辣条'</span><span class="token punctuation">,</span>    <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'食品'</span><span class="token punctuation">,</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'咖啡'</span><span class="token punctuation">,</span>    <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
解决方案：
 <span class="token number">1.</span>创建空对象obj：找出arr中type的种类和对应的数量（利用对象属性名唯一的特点）
 <span class="token number">2.</span>创建空数组arr1：存储二维数组
 <span class="token number">3.</span>遍历arr，根据obj对象，将arr拆分成二维数组存储arr1中
 
<span class="token comment">// 1.创建空对象：找出arr中的type的种类</span>
 <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token keyword">var</span> arrNew <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
 arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">.</span>type<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         arrNew<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
             <span class="token literal-property property">type</span><span class="token operator">:</span> item<span class="token punctuation">.</span>type<span class="token punctuation">,</span>
             <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span>item<span class="token punctuation">]</span>
         <span class="token punctuation">}</span><span class="token punctuation">)</span>
         obj<span class="token punctuation">[</span>item<span class="token punctuation">.</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 说明现在遍历的这个数据的type，在arrNew中已经存在</span>
         arrNew<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span>item2<span class="token punctuation">.</span>type <span class="token operator">==</span> item<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                 item2<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
             <span class="token punctuation">}</span>
         <span class="token punctuation">}</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arrNew<span class="token punctuation">)</span>
<span class="token comment">// obj: {type: ''}</span>
<span class="token comment">// arrNew: [{type: '', data: []}, {type: '', data: []}, ...]</span>
</code></pre></div><h3 id="_7-需求-有一个高度自适应的div-里面有两个div-一个高度100px-希望另一个填满剩下的高度。"><a href="#_7-需求-有一个高度自适应的div-里面有两个div-一个高度100px-希望另一个填满剩下的高度。" class="header-anchor">#</a> 7.需求：有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
    <span class="token selector">*</span> <span class="token punctuation">{</span>
        <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
        <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 方法一 */</span>
    <span class="token selector">.content</span> <span class="token punctuation">{</span>
        <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
        <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>
        <span class="token property">border</span><span class="token punctuation">:</span> 1px solid blue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">.top</span> <span class="token punctuation">{</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">.bottom</span> <span class="token punctuation">{</span>
        <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>
        <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 方法二 */</span>
    <span class="token selector">.content</span> <span class="token punctuation">{</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
        <span class="token property">border</span><span class="token punctuation">:</span> 1px solid blue<span class="token punctuation">;</span>
        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">.top</span> <span class="token punctuation">{</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">.bottom</span> <span class="token punctuation">{</span>
        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
        <span class="token property">top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
        <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
        <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
        <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
        <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 方法三 */</span>
    <span class="token selector">.content</span> <span class="token punctuation">{</span>
        <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
        <span class="token property">border</span><span class="token punctuation">:</span> 1px solid blue<span class="token punctuation">;</span>
        <span class="token property">padding-top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
        <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">.top</span> <span class="token punctuation">{</span>
        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
        <span class="token property">margin-top</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
        <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">.bottom</span> <span class="token punctuation">{</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
        <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>content<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>top<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bottom<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="_8-输出以下代码的打印结果-let定义的变量-定时器"><a href="#_8-输出以下代码的打印结果-let定义的变量-定时器" class="header-anchor">#</a> 8.输出以下代码的打印结果（let定义的变量，定时器）</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 打印结果：
0
1
2
3
4
*/</span>
</code></pre></div><h3 id="_10-需求-将a-a-1-b-b-2-a-3-两个对象合并成一个新对象-a-3-b-2"><a href="#_10-需求-将a-a-1-b-b-2-a-3-两个对象合并成一个新对象-a-3-b-2" class="header-anchor">#</a> 10.需求：将a={a:1}，b={b:2,a:3}两个对象合并成一个新对象{a:3,b:2}</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span>
<span class="token comment">// 方法一</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">}</span>
<span class="token comment">// 方法二</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
</code></pre></div><p>###11.输出打印结果（变量、函数提升）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> bb <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">function</span> <span class="token function">aa</span><span class="token punctuation">(</span><span class="token parameter">bb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bb <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>bb<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">aa</span><span class="token punctuation">(</span>bb<span class="token punctuation">)</span>
<span class="token function">alert</span><span class="token punctuation">(</span>bb<span class="token punctuation">)</span>
<span class="token comment">/* 输出结果：
2
1 */</span>
</code></pre></div><h2 id="第十部分-扩展"><a href="#第十部分-扩展" class="header-anchor">#</a> 第十部分：扩展</h2> <h3 id="_1-向面试官提问"><a href="#_1-向面试官提问" class="header-anchor">#</a> 1.向面试官提问</h3> <p>1.请问，目前咱们公司招聘的这个岗位负责的项目主要是用到什么技术呢？</p> <p>2.这个岗位现在是希望招聘一个什么样的人？</p> <p>3.公司会给这个岗位的员工哪些培养呢？</p> <p>4.你认为咱们公司在用人上是怎么思考的，希望我们在工作的时候以什么样的原则或者说共识去处理事情？</p> <h3 id="_2-数据库mysql相关"><a href="#_2-数据库mysql相关" class="header-anchor">#</a> 2.数据库mysql相关</h3> <p>去重 distinct</p> <p>用一条sql语句，取某个数据去重后的第一条完整数据</p> <p>select distinct * from books limit 1</p> <p>分组：group by</p> <p>更新</p> <p>多表连查：</p> <h3 id="_3-代码实现-字符串去空格"><a href="#_3-代码实现-字符串去空格" class="header-anchor">#</a> 3.代码实现，字符串去空格</h3> <p>第一种方式：字符串的replace()方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">' ab c d '</span>
<span class="token keyword">var</span> newStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex"> </span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>newStr<span class="token punctuation">)</span>
</code></pre></div><p>第二种方式：字符串分组split()再拼接join()</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">' ab c d '</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
<span class="token keyword">var</span> newStr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>newStr<span class="token punctuation">)</span>
</code></pre></div><h2 id="第十一部分-项目"><a href="#第十一部分-项目" class="header-anchor">#</a> 第十一部分：项目</h2> <h3 id="中国人保销售人员和中介管理系统"><a href="#中国人保销售人员和中介管理系统" class="header-anchor">#</a> 中国人保销售人员和中介管理系统</h3> <p>项目中遇到的问题</p> <h4 id="_1-element下拉框组件绑定visible-change事件后频繁调用接口弹出confirm提示框"><a href="#_1-element下拉框组件绑定visible-change事件后频繁调用接口弹出confirm提示框" class="header-anchor">#</a> 1.element下拉框组件绑定visible-change事件后频繁调用接口弹出confirm提示框</h4> <p>问题描述：</p> <p>给element下拉框组件select绑定visible-change事件，下拉框显示时触发函数调用接口，没有cofirm提示框的时候仅调用一次接口，当出现confirm提示框时就频繁调接口，频繁弹出提示框。</p> <p>原因：</p> <p>当弹出提示框后，关闭提示框的时候，select组件失去焦点，visible-change的$event参数变成false，但是立刻又重新获取焦点，再次触发visible-change事件，调用接口，弹出confirm提示。</p> <p>解决办法：</p> <p>在弹出提示框之后，手动让select组件失去焦点。调用select下拉框的blur()方法</p> <h3 id="新闻头条后台管理系统-pc端"><a href="#新闻头条后台管理系统-pc端" class="header-anchor">#</a> 新闻头条后台管理系统（PC端）</h3> <p>项目中遇到的问题：</p> <h4 id="_1-在删除文章时-无法准确的删除某条指定id的文章"><a href="#_1-在删除文章时-无法准确的删除某条指定id的文章" class="header-anchor">#</a> 1.在删除文章时，无法准确的删除某条指定id的文章</h4> <p>原因是JavaScript能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。而后端生成的id是按照一定规则生成的长整数，超出了JavaScript能准确表示的范围，导致不能准确的删除某项数据。</p> <p>后端返回的数据一般都是JSON格式的字符串，而axios会在内部使用JSON.parse()把后端返回的数据转为JavaScript数据对象。超出安全整数的id无法精确表示，所以解决思路就是：不要让axios使用JSON.parse()来转换这个数据，而是使用json-bigint来做转换处理。</p> <p>axios提供了一个API：transformResponse配置项，这个配置项控制在传递给then/catch前，允许修改响应数据。在配置项中使用json-bigint进行数据转换，后端返回的数据可能不是JSON格式字符串，如果不是，那个JSONbig.parse()调用可能会报错，所以我们使用try-catch来捕获异常，处理异常的发生。如果转换成功，则把转换后的结果返回，如果转换失败，则把数据原封不动的直接返回给请求使用。</p> <p>使用id的地方用.toString()进行转换。</p> <h4 id="_2-在element-tiptap中上传本地图片"><a href="#_2-在element-tiptap中上传本地图片" class="header-anchor">#</a> 2.在element-tiptap中上传本地图片</h4> <p>tiptap：专门基于Vue框架开发的富文本编辑器。</p> <p>element-tiptap：基于tiptap制作的，样式风格采用element样式的富文本编辑器。</p> <p>问题：默认从本地上传的图片是base64格式的字符串，这样当加载多个图片时会拖慢响应速度。</p> <p>解决办法：图片上传到服务器，服务器对图片进行处理，生成一个url地址返回给客户端。</p> <p>在element-tiptap组件的extensions配置项的Image实例中配置uploadRequest()函数。将base64格式的图片上传到服务器，在服务器中对图片进行处理，将服务器返回的图片链接地址返回给客户端。</p> <blockquote><p>一般文件上传的接口都要求把请求头中的Content-Type设置为multipart/form-data，但是我们使用axios上传的话不需要手动设置，你只要给data一个FormData对象即可。</p></blockquote> <h3 id="新闻头条移动端"><a href="#新闻头条移动端" class="header-anchor">#</a> 新闻头条移动端</h3> <h4 id="_1-如何做移动端rem适配"><a href="#_1-如何做移动端rem适配" class="header-anchor">#</a> 1.如何做移动端rem适配</h4> <ol><li>使用lib-flexible插件动态设置rem基准值（html标签的字体大小）</li> <li>使用postcss-pxtorem将px转为rem</li> <li>设计稿的是以iPhone6/7/8为原型，iPhone6/7/8设备的宽是750，我们设计稿也是这样。我们是基于lib-flexible的rem适配方案，所以根元素大小设置为设计稿的十分之一，例如设计稿是750宽，则应该设置为75。但是Vant是基于375写的，如果设置为75的话，Vant的样式就小一半。这里我们选择设置为37.5。</li> <li>Vant的样式是没有问题的，但是我们在测量设计稿的时候都必须除2才能使用，否则就会变得很大。为了不用除2，我们这样做：在photoshop中打开单位与标尺，将单位中的标尺和文字的单位修改为点，然后打开设置图像大小面板，关闭重新采样，将宽度和高度的单位设置为点，将宽度修改为375，高度不用动（它会适应宽度自动调整）。这样就可以不用除以2，直接写设计稿上测量的大小。</li></ol> <h4 id="_2-关于token过期问题"><a href="#_2-关于token过期问题" class="header-anchor">#</a> 2.关于token过期问题</h4> <p>登录成功之后后端返回两个token，一个访问token，有效期2小时，一个刷新token，有效期14天，用于访问令牌过期之后重新获取新的访问令牌。</p> <p>具体做法是在axios请求中（响应拦截器中）加入token刷新逻辑，当用户token过期时（状态码401），去向服务器请求新的token，把旧的token替换为新的token，然后继续用户当前的请求。</p> <h4 id="_3-解决评论回复弹层中组件内容不更新问题"><a href="#_3-解决评论回复弹层中组件内容不更新问题" class="header-anchor">#</a> 3.解决评论回复弹层中组件内容不更新问题</h4> <p>弹层组件：</p> <ul><li>如果初识的条件是false，则弹层的内容不会渲染</li> <li>程序运行期间，当条件变为true的时候，弹层才渲染了内容</li> <li>之后切换弹层的展示，弹层只是通过CSS控制隐藏和显示</li></ul> <p>弹层渲染出来以后就只是简单的切换显示和隐藏，里面的内容也不再重新渲染了，所以会导致我们的评论的回复列表不会动态更新了。解决办法就是在每次弹层显示的时候重新渲染组件。</p> <p>具体做法是给评论回复组件使用v-if绑定弹出层的显示隐藏属性。</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token comment">&lt;!-- 评论回复 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>van-popup</span>
  <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>isReplyShow<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">get-container</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>body<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">round</span>
  <span class="token attr-name">position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bottom<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">:style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ height: '90%' }<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 回复列表 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>comment-reply</span> <span class="token attr-name">:comment</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>currentComment<span class="token punctuation">&quot;</span></span> <span class="token attr-name">+</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>isReplyShow<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token comment">&lt;!-- /回复列表 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>van-popup</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 评论回复 --&gt;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/Vue3/vue3快速上手.html" class="prev">
        vue3快速上手
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2d1dd0b0.js" defer></script><script src="/assets/js/2.07c258a3.js" defer></script><script src="/assets/js/4.7c3dfb1b.js" defer></script>
  </body>
</html>
